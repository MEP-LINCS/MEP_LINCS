
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE)
```


```{r }
#Author: Mark Dane, copyright 2015

source("./MEPLINCSFunctions.R")

```



```{r setup,cache=FALSE}
library("ggplot2")
library("data.table")
library("MEMA")
library("grid")
library("knitr")
library("gplots")
library("RColorBrewer")
library(DT)
library(d3heatmap)
library(plotly)
library(corrplot)

#Setup colors for Barcode and text in all heatmaps
selDark2 <- colorRampPalette(brewer.pal(8,"Dark2"))
plateCol = selDark2(8)
hmcols<-colorRampPalette(c("blue","white","red"))(16)

l1 <- fread(paste0("./",cellLine,"/",ss,"/AnnotatedData/",cellLine,"_",ss,"_",rawDataVersion,"_",analysisVersion,"_Level1.txt"), showProgress = FALSE)
l2 <- fread(paste0("./",cellLine,"/",ss,"/AnnotatedData/",cellLine,"_",ss,"_",rawDataVersion,"_",analysisVersion,"_Level2.txt"), showProgress = FALSE)
l3 <- fread(paste0("./",cellLine,"/",ss,"/AnnotatedData/",cellLine, "_",ss,"_",rawDataVersion,"_",analysisVersion,"_Level3.txt"), showProgress = FALSE)
l4 <- fread(paste0("./",cellLine,"/",ss,"/AnnotatedData/",cellLine, "_",ss,"_",rawDataVersion,"_",analysisVersion,"_Level4.txt"), showProgress = FALSE)

barcodes <- sort(unique(l3$Barcode))


#Set a threshold for filtering wells on their QA score
wellQAThresh <- 0.7

#TODO: Read this from Level 3 data
lthresh <- 0.6

#Number of PCS components to use
nrPCs <- 9

#Z score threshold for extreme spot cell count
SCCZscoreThresh <- 3

#Spot cell count threshold for HF dataset
HFSCCThresh <- 20

#Replicate count threshold for HF Dataset
HFRepThresh <- 3

# https://meplincs.ohsu.edu/webclient/
  
if(!analysisVersion=="v1"){
      l3$OmeroDetailURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/img_detail/',l3$ImageID,'/"',' target="_blank">Omero</a>')
  l3$OmeroThumbnailURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/render_thumbnail/',l3$ImageID,'/"',' target="_blank">Omero</a>')
  l3$OmeroImageURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/render_image/',l3$ImageID,'/"',' target="_blank">Omero</a>')
}

```


#MEP-LINCS `r cellLine` `r ss` Phase 1 Analysis, CP Pipeline `r rawDataVersion` ,Analysis Version `r analysisVersion`
####date: `r Sys.Date()`

##Summary
The MEP-LINCS `r cellLine` `r ss` datasets include four levels of high content imaging data from on Microenvironment Microarrays (MEMAs). After QA filtering, there are `r nrow(l4[!grepl("PBS|Fiducial",l4$ECMpAnnotID),][!grepl("FBS",l4$LigandAnnotID)])` Microenvironment Perturbations (MEPs) that are pairwise combinations of `r length(unique(l4$ECMpAnnotID[!grepl("PBS|Fiducial",l4$ECMpAnnotID)]))` printed ECM proteins and `r length(unique(l4$LigandAnnotID[!grepl("FBS",l4$LigandAnnotID)]))` ligands or growth factors.  

##Introduction
The LINCS Pilot `r cellLine` `r ss` experiment was performed with cells grown in `r length(barcodes)` 8-well plates. The `r ss` staining set includes, DAPI, `r unique(l4$Endpoint488)`, `r unique(l4$Endpoint555)` and `r unique(l4$Endpoint647)`. Color images of the cells at each spot were gathered on a Nikon automated microscope.

Intensity, position and a limited set of morphology data are gathered for each cell, merged with the experiment metadata, normalized, filtered and summarized. The dataset is organized into the four LINCS imaging categories as follows:

Level 1 - Raw data  
Level 2 - Normalized data  
Level 3 - Normalized data aggregated to the spot level  
Level 4 - Normalized data aggregated to the replicate (MEP) level  

The data merging and analysis is done in R using open source software. 

```{r Filtering, echo=FALSE}

#Remove the fiducial and blank data
setkey(l3,ECMp)
l3F <- l3[!grepl("fiducial|Fiducial|blank|PBS",l3$ECMp),]
l3F <- l3F[!grepl("FBS", l3F$Ligand)]

#Remove failed QA wells
l3F <- l3F[!l3F$QA_LowWellQA]
l4F <- createl4(l3F)
#Add Robust Z Scores of the normalized Spot Cell Counts #across the entire staining set
l4F <- l4F[,Spot_PA_SpotCellCount_Norm_RobustZ := RZScore(Spot_PA_SpotCellCount_Norm)]

if (grepl("SS2",ss)){
  #Add Robust Z Score of the Edu Signal
  l4F <- l4F[,Nuclei_PA_Gated_EduPositiveProportion_Norm_RobustZ := RZScore(Nuclei_PA_Gated_EduPositiveProportion_Norm)]
}

if (grepl("SS3",ss)){
  #Add Robust Z Scores of the normalized lineage ratios
  l4F <- l4F[, Cytoplasm_PA_Intensity_LineageRatio_Norm_RobustZ:= RZScore(Cytoplasm_PA_Intensity_LineageRatio_Norm)]
  
}

#Filter for high spot occupancy and good quality DAPI####
l3HF <- l3F[l3F$Spot_PA_SpotCellCount > HFSCCThresh]
l3HF <- l3HF[!l3HF$QA_LowDAPIQuality]
l3HF <- l3HF[!l3HF$QA_LowRegionCellCount]
l4HF <- createl4(l3HF)
l4HF <- l4HF[l4HF$Spot_PA_ReplicateCount >= HFRepThresh]

```

```{r, child='MEP-LINCS_RUV3Text.Rmd', eval=unique(l3$NormMethod)=="RUV3"}
```


```{r, child='MEP-LINCS_MitoText.Rmd', eval=grepl("SS1",ss)}
```

<br>

```{r MitoTrackerByMEP, eval=grepl("SS1",ss), fig.width=8, fig.height=6}
setkey(l4HF,"Ligand")
dt <- l4HF[!"FBS"]

p <- ggplot(dt, aes(x =reorder(MEP, Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm), y = Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm))+
  geom_errorbar(aes(ymin=Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm-Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm_SE, ymax=Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm+Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm_SE), width=.01, colour="black") +
  xlab("MEP")+ylab("Normalized, MitoTracker Intensity Ratio")+
  coord_cartesian(ylim=c(.9*min(dt$Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm), 1.1*max(dt$Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm)))+
  geom_point(colour = "green", alpha = .5)+
  theme( axis.text.x=element_blank(), axis.ticks=element_blank(),  panel.grid.major = element_blank())+
  ggtitle("MEPs Ordered by MitoTracker Intensity with SE Bars")

ggplotly(p)
```


```{r MitoTrackerMEPS, echo = FALSE, eval=grepl("SS1",ss)}

setkey(dt, Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm)
datatable(format(dt[,list(MEP,Barcode, Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm,Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm_SE,Spot_PA_ReplicateCount)], digits=2, scientific = FALSE, nsmall=0), options = list(pageLength = 5), colnames = c("MEP", "Barcode", "MitoTracker Int.", "MitoTracker Int. SE", "Replicate Count"))

if(!analysisVersion=="v1"){
  setkey(l3HF, Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm)
  datatable(format(l3HF[,list(MEP,Barcode,OmeroDetailURL,ArrayRow,ArrayColumn, Cytoplasm_CP_Intensity_MedianIntensity_MitoTracker_Norm)], digits=2, scientific = FALSE, nsmall=0), options = list(pageLength = 5), colnames = c("MEP", "Barcode","Omero","Row","Column","MitoTracker Int."),escape = FALSE)
}
```


```{r, child='MEP-LINCS_ProliferationText.Rmd', eval=grepl("SS2",ss)}
```

<br>

##Filtering
A highly filtered dataset termed "HF" is created as follows. Spots with less than `r HFSCCThresh` cells, wells with QA scores below `r wellQAThresh `, wells with low quality DAPI, MEPS with less than `r HFRepThresh` replicates and the FBS control wells are removed from further analysis of the dataset. After filtering there are `r length(unique(l4HF$MEP))` unique MEPs in the HF dataset. 


```{r NormedProliferationByMEP,eval=grepl("SS2",ss), fig.width=8, fig.height=6}

setkey(l4HF,"Ligand")
dt <- l4HF[!grepl("FBS",l4HF$Ligand)]

p <- ggplot(dt, aes(x =reorder(MEP, Nuclei_PA_Gated_EduPositiveLogit_Norm), y = Nuclei_PA_Gated_EduPositiveLogit_Norm))+
  geom_errorbar(aes(ymin=Nuclei_PA_Gated_EduPositiveLogit_Norm-Nuclei_PA_Gated_EduPositiveLogit_Norm_SE, ymax=Nuclei_PA_Gated_EduPositiveLogit_Norm+Nuclei_PA_Gated_EduPositiveLogit_Norm_SE), width=.01, colour="black") +
  xlab("MEP")+ylab("Normalized, EdU+ Proportion Ratio")+
  geom_point(colour = "red", alpha = .5)+
  theme( axis.text.x=element_blank(), axis.ticks=element_blank(),  panel.grid.major = element_blank())+
  ggtitle("MEPs Ordered by EdU+ Proportion with SE Bars")

ggplotly(p)
```


```{r ProliferationByMEP,eval=grepl("SS2",ss), fig.width=8, fig.height=6}

p <- ggplot(dt, aes(x =reorder(MEP, Nuclei_PA_Gated_EduPositiveProportion), y = Nuclei_PA_Gated_EduPositiveProportion))+
  #geom_errorbar(aes(ymin=Nuclei_PA_Gated_EduPositiveLogit_Norm-Nuclei_PA_Gated_EduPositiveLogit_Norm_SE, ymax=Nuclei_PA_Gated_EduPositiveLogit_Norm+Nuclei_PA_Gated_EduPositiveLogit_Norm_SE), width=.01, colour="black") +
  xlab("MEP")+ylab("EdU+ Proportion")+
  geom_point(colour = "red", alpha = .5)+
  theme( axis.text.x=element_blank(), axis.ticks=element_blank(),  panel.grid.major = element_blank())+
  ggtitle("MEPs Ordered by EdU+ Proportion")

ggplotly(p)
```


```{r EdUProportionMEPS, echo = FALSE,eval=grepl("SS2",ss)}

setkey(dt, Nuclei_PA_Gated_EduPositiveProportion)
datatable(format(dt[,list(MEP,Barcode, Nuclei_PA_Gated_EduPositiveProportion,Nuclei_PA_Gated_EduPositiveLogit_Norm,Nuclei_PA_Gated_EduPositiveLogit_Norm_SE,Spot_PA_ReplicateCount)], digits=2, scientific = FALSE, nsmall=0), options = list(pageLength = 5), colnames = c("MEP", "Barcode", "EDU+ Prop","EDU+ Prop Norm", "EDU+ Prop Norm SE", "Replicate Count"))

if(!analysisVersion=="v1"){
  setkey(l3HF, Nuclei_PA_Gated_EduPositiveProportion)
  datatable(format(l3HF[,list(MEP,Barcode,Well,ArrayRow,ArrayColumn,Spot_PA_SpotCellCount, Nuclei_PA_Gated_EduPositiveProportion,Nuclei_PA_Gated_EduPositiveLogit_Norm, OmeroDetailURL)], digits=2, scientific = FALSE, nsmall=0), options = list(pageLength = 5), colnames = c("MEP", "Barcode","Well","Row","Column","SCC","EDU+ Prop.","EDU+ Prop Norm","Omero"),escape = FALSE)
}
```


```{r, child='MEP-LINCS_LineageText.Rmd',eval=grepl("SS3",ss)}
```

```{r LineageRatioByMEP,eval=grepl("SS3",ss), fig.width=8, fig.height=6}

setkey(l4HF,"Ligand")
dt <- l4HF[!"FBS"]

p <- ggplot(dt, aes(x =reorder(MEP, Cytoplasm_PA_Intensity_LineageRatioLog2_Norm), y = Cytoplasm_PA_Intensity_LineageRatioLog2_Norm))+
  geom_errorbar(aes(ymin=Cytoplasm_PA_Intensity_LineageRatioLog2_Norm-Cytoplasm_PA_Intensity_LineageRatioLog2_Norm_SE, ymax=Cytoplasm_PA_Intensity_LineageRatioLog2_Norm+Cytoplasm_PA_Intensity_LineageRatioLog2_Norm_SE), width=.01, colour="black") +
  xlab("MEP")+ylab("Normalized, Logged Lineage Ratio")+
  geom_point(colour = "blue", alpha = .5)+
  theme( axis.text.x=element_blank(), axis.ticks=element_blank(),  panel.grid.major = element_blank())+
  ggtitle("MEPs Ordered by Logged Lineage Ratio with SE Bars")

ggplotly(p)
```


```{r LineageRatioMEPS, echo = FALSE,eval=grepl("SS3",ss)}

setkey(dt, Cytoplasm_PA_Intensity_LineageRatioLog2_Norm)
datatable(format(dt[,list(MEP,Barcode, Cytoplasm_PA_Intensity_LineageRatioLog2_Norm,Cytoplasm_PA_Intensity_LineageRatioLog2_Norm_SE,Spot_PA_ReplicateCount)], digits=2, scientific = FALSE, nsmall=0), options = list(pageLength = 5), colnames = c("MEP", "Barcode", "Lineage Ratio", "Lineage Ratio SE", "Replicate Count"))

if(!analysisVersion=="v1"){
  setkey(l3HF, Cytoplasm_PA_Intensity_LineageRatioLog2_Norm)
  datatable(format(l3HF[,list(MEP,Barcode,OmeroDetailURL,ArrayRow,ArrayColumn, Cytoplasm_PA_Intensity_LineageRatio_Norm)], digits=2, scientific = FALSE, nsmall=0), options = list(pageLength = 5), colnames = c("MEP", "Barcode","Omero", "Row","Column","LineageRatio"),escape = FALSE)
}
```
##DNA Content Analysis

All cells are stained with DAPI and classified as DNA 2n or 4n. The proportion of 2n and 4n cells at each spot is calculated and will always sum to 1. The proportions are plotted below and detailed in the datatables.


```{r DNA2NByMEP, fig.width=8, fig.height=6}

setkey(l4HF,"Ligand")
dt <- l4HF[!grepl("FBS",l4HF$Ligand)]

p <- ggplot(dt, aes(x =reorder(MEP, Nuclei_PA_Cycle_DNA2NProportion), y = Nuclei_PA_Cycle_DNA2NProportion))+
  #geom_errorbar(aes(ymin=Nuclei_PA_Gated_EduPositiveLogit_Norm-Nuclei_PA_Gated_EduPositiveLogit_Norm_SE, ymax=Nuclei_PA_Gated_EduPositiveLogit_Norm+Nuclei_PA_Gated_EduPositiveLogit_Norm_SE), width=.01, colour="black") +
  xlab("MEP")+ylab("DNA 2N Proportion Ratio")+
  geom_point(colour = "red", alpha = .5)+
  theme( axis.text.x=element_blank(), axis.ticks=element_blank(),  panel.grid.major = element_blank())+
  ggtitle("MEPs Ordered by DNA Proportion")

p <- p + geom_point(aes(y=Nuclei_PA_Cycle_DNA4NProportion),colour = "blue", alpha = .5)

ggplotly(p)

```




##Spot Cell Count Analysis
The spot cell count analysis uses robust Z scores to identify MEPs with extreme population sizes. The normalized spot cell counts are summarized by the median of their replicates. The median and mad of the distribution of normalized and summarized values are used to convert to robust Z scores and are shown below. Below the distribution plot are plots with Z scores stratified by ligand and ECM protein. 

<br>
```{r SCCRobustZScores, echo=FALSE, fig.width=8, fig.height=3.5, eval=TRUE}

plotSCCRobustZScores(l4F,thresh = SCCZscoreThresh)
```


###Normalized Spot Cell Counts

The interactive heatmap below is arranged by unsupervised clustering of the rows and columns and colored by the normalized spot cell count Z scores. Clicking and dragging across any subsection will zoom in on that section. Double clicking on the zoomed image will return to the full heatmap.  

```{r SCCHeatmap, fig.width=8, fig.height=5}

#Cast to get  into ligands and barcodes into rows
df <- dcast(data.frame(l4F[,list(ECMp,Ligand,Spot_PA_SpotCellCount_Norm_RobustZ,Barcode)]),Barcode+Ligand~ECMp, value.var = "Spot_PA_SpotCellCount_Norm_RobustZ")

rownames(df) <- df$Ligand
rowPal <- brewer.pal(8,"Dark2")
barcodeCols <- rowPal[as.factor(df$Barcode)]

#Cast again to get ligands into columns
df <- dcast(data.frame(l4F[,list(ECMp,Ligand,Spot_PA_SpotCellCount_Norm_RobustZ,Barcode)]),ECMp~Ligand, value.var = "Spot_PA_SpotCellCount_Norm_RobustZ")

rownames(df) <- df$ECMp
df <- df[,!grepl("ECMp",names(df))]

dfZoom <- function(x, min=.02, max=1){
  minMax <- quantile(unlist(x), probs=c(min,max))
  cl <- t(apply(x,1, function(c){
    c[c<minMax[1]] <- minMax[1]
    c[c>minMax[2]] <- minMax[2]
    return(c)
  }))
  return(data.frame(cl))
}

d3heatmap(dfZoom(df, .01, .99), colors=hmcols, xaxis_font_size="6pt", yaxis_font_size="5pt")

```

```{r SCCTable}
setkey(l4F,"Ligand")
dt <- l4F[!grepl("FBS",l4F$Ligand)]

setkey(dt, Spot_PA_SpotCellCount_Norm_RobustZ)
datatable(format(dt[, list(ECMp, Ligand,Barcode,Spot_PA_SpotCellCount_Norm_RobustZ, Spot_PA_SpotCellCount, Spot_PA_ReplicateCount)], digits=1, scientific = FALSE, nsmall=0), options = list(pageLength = 5), colnames = c("ECMp","Ligand","Barcode","Spot Cell Count Z Score","Spot Cell Count","Replicate Count"))

```

##Unbiased Analysis

The unbiased analysis approach is:  
Normalize the cell level data using the median and MAD of each plate's control well
Median summarize the normalized data to the spot level
Median summarize the spot level data to the MEP level  
Select a curated feature vector of MEP intensities and morphologies  
Calculate the euclidean distance of each MEP's feature vector to the control feature vector  
Perform hierarchical clustering on the MEPs 

The following heatmap shows the normalized MEP responses based on the curated feature vector and the normalized dataset. The heatmap is arranged by unsupervised clustering of the rows and columns and colored by the normalized feature vector values. Clicking and dragging across any subsection will zoom in on that section. Double clicking on the zoomed image will return to the full heatmap.  

```{r}

lowQALigands <- unique(l3$Ligand[l3$QA_LowWellQA])
fvDT <- filterl4(l4, lowQALigands)
setkey(fvDT, MEP)
fvDT <- fvDT[!grepl("FBS|Fiducial|fiducial|blank|PBS",fvDT$MEP),]
fvDT <- fvDT[,Barcode := NULL]

#Shorten the feature names
setnames(fvDT,grep("Barcode|MEP",colnames(fvDT), value = TRUE, invert = TRUE),gsub(".*_","",gsub("_Norm","",grep("Barcode|MEP",colnames(fvDT), value = TRUE, invert = TRUE))))
#Remove when not needed
if("2NProportion" %in% colnames(fvDT)) setnames(fvDT,"2NProportion","DNA2NProportion")

#Convert to dataframe for use in D3heatmap
fvDT <- data.frame(fvDT)
rownames(fvDT) <- fvDT$MEP

fvDT <- fvDT[,!(names(fvDT) %in% c("MEP"))]
```


```{r, fig.height=8, fig.width=7, eval = TRUE}

d3heatmap(fvDT, scale="column", colors=hmcols, xaxis_font_size="6pt", yaxis_font_size="4pt", show_grid = FALSE)

```


###PCA Unbiased Analysis  
The unbiased analysis is extended by using Principal Component Analysis (PCA) to reduce the dimensions of the feature vector.

The unbiased PCA analysis method is:
Use PCA to transform the entire normalized feature set to a much smaller number of principal components (PCFV).  
Perform unsupervised hierarchical clustering of the first `r nrPCs` PCFVs.  


The heatmap is arranged by unsupervised clustering of the rows and columns and colored by the normalized principal component values. Clicking and dragging across any subsection will zoom in on that section. Double clicking on the zoomed image will return to the full heatmap. 

```{r,}
#l4F <- l4F[!grepl("NID1",l4F$ECMp)]

PCFVNames <- grep("Norm",colnames(l4F),value=TRUE)
PCFVNames <- grep("Euler|MaximumRadius|_SE|_RobustZ",PCFVNames,invert = TRUE, value = TRUE)

#Get the PCFVs
l4PCAModel <- prcomp(as.formula(paste(" ~ ", paste(PCFVNames, collapse = "+"))), data = l4F, scale= TRUE)

#Extract the first PCs of each MEP into a matrix
l4pcvDT <- data.table(l4PCAModel$x[,1:nrPCs],Barcode =l4F$Barcode, MEP = l4F$MEP)

#Convert to dataframe for use in D3heatmap
l4pcvDT <- data.frame(l4pcvDT)
rownames(l4pcvDT) <- l4pcvDT$MEP
l4pcvDT <- l4pcvDT[,!(names(l4pcvDT) %in% c("MEP", "Barcode"))]

```

```{r PCAHeatmap, fig.height=8, fig.width=7}
#Plot the heat map of the entire dataset
d3heatmap(l4pcvDT, scale="column", colors=hmcols, xaxis_font_size="6pt", yaxis_font_size="4pt", show_grid = FALSE)
```

```{r, fig.height=3, fig.width=4}

var <- l4PCAModel$sd[1:nrPCs]^2
var.percent <- var/sum(var) * 100
barplot(var.percent, xlab="PC", ylab="Percent Variance", names.arg=1:length(var.percent), las=1, ylim=c(0,max(var.percent)), col="gray", main  = paste("PCA Scree Plot for",cellLine,ss))

p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC2, col = l4F$Barcode)) +
  geom_point(size = rel(.7), alpha = .8) +
  labs(colour = "Barcode")+
  theme(legend.text=element_text(size = 6))+
  guides(colour = guide_legend(override.aes = list(size=6)))
print(p)

p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC3, col = l4F$Barcode)) +
  geom_point(size = rel(.7), alpha = .8) +
  labs(colour = "Barcode")+
  theme(legend.text=element_text(size = 6))+
  guides(colour = guide_legend(override.aes = list(size=6)))
print(p)

p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC2, y = PC3, col = l4F$Barcode)) +
  geom_point(size = rel(.7), alpha = .8) +
  labs(colour = "Barcode")+
  theme(legend.text=element_text(size = 6))+
  guides(colour = guide_legend(override.aes = list(size=6)))
print(p)

if(grepl("SS1",ss)){
  p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC2, col = l4F$Cytoplasm_CP_Intensity_IntegratedIntensity_MitoTracker_Norm)) +
    geom_point(size = rel(.7), alpha = .8) +
    labs(colour = "Total MitoTracker")+
    theme(legend.text=element_text(size = 6))+
    guides(colour = guide_legend(override.aes = list(size=6)))
  print(p)
  
  
  p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC2, col = l4F$Cells_CP_AreaShape_Perimeter_Norm)) +
    geom_point(size = rel(.7), alpha = .8) +
    labs(colour = "Perimeter ProportionStatus")+
    theme(legend.text=element_text(size = 6))+
    guides(colour = guide_legend(override.aes = list(size=6)))
  print(p)
} else if (ss=="SS2"){
  
} else if (ss=="SS3"){
  
  
  p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC2, col = l4F$Cytoplasm_PA_Intensity_LineageRatio_Norm)) +
    geom_point(size = rel(.7), alpha = .8) +
    labs(colour = "Lineage Ratio")+
    theme(legend.text=element_text(size = 6))+
    guides(colour = guide_legend(override.aes = list(size=6)))
  print(p)
  
  
  p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC3, y = PC4, col = l4F$Cytoplasm_PA_Intensity_LineageRatio_Norm)) +
    geom_point(size = rel(.7), alpha = .8) +
    labs(colour = "Lineage Ratio")+
    theme(legend.text=element_text(size = 6))+
    guides(colour = guide_legend(override.aes = list(size=6)))
  print(p)
  
  p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC5, y = PC6, col = l4F$Cytoplasm_PA_Intensity_LineageRatio_Norm)) +
    geom_point(size = rel(.7), alpha = .8) +
    labs(colour = "Lineage Ratio")+
    theme(legend.text=element_text(size = 6))+
    guides(colour = guide_legend(override.aes = list(size=6)))
  print(p)
  
  p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC7, y = PC8, col = l4F$Cytoplasm_PA_Intensity_LineageRatio_Norm)) +
    geom_point(size = rel(.7), alpha = .8) +
    labs(colour = "Lineage Ratio")+
    theme(legend.text=element_text(size = 6))+
    guides(colour = guide_legend(override.aes = list(size=6)))
  print(p)
  
}

datatable(format(l4PCAModel$rotation[,1:nrPCs], digits=1, scientific = FALSE, nsmall=0), options = list(pageLength = 5))
#Extract the selectedPCs of each MEP into a matrix

```

