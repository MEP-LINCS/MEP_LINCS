---
output: html_document
---

```{r global_options_Setup, include=FALSE}
#Author: Mark Dane, copyright 2016

knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE)

```

```{r}

library("ggplot2")
library("reshape2")
library("data.table")
library("limma")
library("MEMA")
library("grid")
library("knitr")
library("gplots")
library("RColorBrewer")
library(plotly)

x <- data.table(CellLine=rep(c("MCF10A"),each=1),
                        StainingSet = rep(c("SS20")),
                        Signal=rep(c("SCC"), each=1),
                        Method=c("RUV3Loess"),
                       inputFileName=rep(c("../AnnotatedData/MCF10A_SS0_none_v2_av1.6_SpotLevel.txt"), each=1))
```


---
title: "MEP-LINCS `r x[["CellLine"]]` `r x[["StainingSet"]]` `r x[["Signal"]]`  SVD Analysis"
date: "`r Sys.Date()`"
---

```{r , include=FALSE}

#source("MEPLINCSFunctions.R")

#Read in file based on name in dataframe
l3 <- fread(x[["inputFileName"]], showProgress = FALSE)
#Cleanup ECMp names in gal file 
l3$ECMp <- sub("_{1}[[:alpha:]]*","",l3$ECMp)
l3$ECMp <- sub("_{1}[[:alnum:]]*","",l3$ECMp)

```


```{r simulatePoorPin, eval=FALSE}

l1$Spot_PA_SpotCellCount[l1$Block==6] <-as.integer( l1$Spot_PA_SpotCellCount[l1$Block==6]*.25+1)

```

```{r simulateEmptyingWell, eval=FALSE}
l1 <- setkey(l1,Barcode,Well,Spot)
l1$Spot_PA_SpotCellCount[l1$Block==5 & l1$Row==1 & l1$Column==1] <-as.integer( l1$Spot_PA_SpotCellCount[l1$Block==5 & l1$Row==1 & l1$Column==1]*seq(1,0,length.out=length(l1$Spot_PA_SpotCellCount[l1$Block==5 & l1$Row==1 & l1$Column==1])))

```

```{r}
#Keep the control wells separate
l3$Ligand[grepl("FBS",l3$Ligand)] <- paste(l3$Ligand[grepl("FBS",l3$Ligand)],"P",as.numeric(factor(l3$Barcode[grepl("FBS",l3$Ligand)])),sep="")
l3$MEP <- paste(l3$ECMp,l3$Ligand,sep="_")

#Delete the fiducial and blank spots
setkey(l3, "ECMp")
l3 <- l3[!grepl("fiducial|Fiducial|blank|PBS",l3$ECMp)]
#Add spatial residuals
l3 <- l3[, SCCRel := calcResidual(Spot_PA_SpotCellCount), by="MEP"]

```

```{r createMatrices}
#For an array  Unit of study there are 64 'samples'of 694 spots with 8 replicates
#Create a spot assignment that recognizes rotated B row arrays
l3$RSpot <- l3$Spot
l3$RSpot[grepl("B",l3$Well)] <- 701-l3$RSpot[grepl("B",l3$Well)]
#Add in ligand and ECMp names so they will carry through the normalization
l3$BWL <- paste(l3$Barcode,l3$Well,l3$Ligand,sep="_")
l3$SE <- paste(l3$RSpot,l3$ECMp,sep="_")
l3$ES <- paste(l3$ECMp,l3$RSpot,sep="_")
l3$ESB <- paste(l3$ECMp,l3$RSpot,l3$Block, sep="_")
l3$BW <- paste(l3$Barcode,l3$Well,sep="_")
l3$WSE <- paste(l3$Well, l3$RSpot,l3$ECMp,sep="_")

#Cast to get mel values by barcode_well_ligand rows and spot columns
#Coerce missing values to have near 0 values
if(x[["Signal"]] %in% c("EdU", "DNA2N", "Ecc","Spot")){
  fill <- log2(.01/(1-.01))
} else if(unique(x[["Signal"]]) %in% c("LineageRatioLog2", "SCC")){
  fill <- 0
} else(stop(paste("Need fill value for",unique(x[["Signal"]])," signal"))) 

```

```{r addResiduals}

l3RelcA <- data.table(dcast(l3, BWL~ES, value.var=paste0(x[["Signal"]],"Rel"), fill = fill))
#Remove the BWL column and use it as rownames in the matrix
l3Relm <- l3RelcA[,grep("BWL",colnames(l3RelcA), value=TRUE, invert=TRUE), with=FALSE]
#Y is a numeric matrix of the raw transformed responses 
#of each spot extracted from the l3 dataset
YRelArray <- matrix(unlist(l3Relm), nrow=nrow(l3Relm), dimnames=list(l3RelcA$BWL, colnames(l3Relm)))
```

```{r}

p <- ggplot(l3, aes(x=ArrayColumn, y=ArrayRow, fill= Spot_PA_SpotCellCount))+
  geom_tile()+
  scale_fill_gradient(low="white",high="red",oob = scales::squish)+
  ggtitle("Spot Cell Count for Qual Wells")+
  xlab("")+ylab("")+
  guides(fill=FALSE)+
  xlim(.5,20.5)+ylim(35.5,.5)+
  facet_wrap(~Barcode, nrow = 1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.6)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), plot.title = element_text(size = rel(.8)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.7)),panel.grid.major = element_line(linetype = 'blank'),panel.background = element_rect(fill = "lightgrey"))
suppressWarnings(print(p))

```


```{r}

p <- ggplot(l3, aes(x=ArrayColumn, y=ArrayRow, fill= SCCRel))+
  geom_tile()+
  scale_fill_gradient(low="white",high="red",oob = scales::squish)+
  ggtitle("Spot Cell Count Residuals for Qual Wells")+
  xlab("")+ylab("")+
  guides(fill=FALSE)+
  xlim(.5,20.5)+ylim(35.5,.5)+
  facet_wrap(~Barcode, nrow = 1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.6)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), plot.title = element_text(size = rel(.8)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.7)),panel.grid.major = element_line(linetype = 'blank'),panel.background = element_rect(fill = "lightgrey"))
suppressWarnings(print(p))

```

###SVD Applied to Array Level

Singular Value Decomposition is applied to the residuals at the array level as follows.  
   * Median summarize the cell level data to the spot level.  
   * Create residuals by subtracting the median value of the replicates from each replicate value
   * Create an M matrix of residuals that is `r nrow(YRelArray)` rows by `r ncol(YRelArray)` columns. Each row holds residuals for each spot in a MEMA.  
   * Apply SVD to the M matrix to get u, d and v matrices.  
   * Plot the eignvector in the column of the v matrix which corresponds to the largest singular value in the d matrix. Plot as heat map of 35 rows and 20 columns.  Missing tiles in the heat map correspond to fiducials and blank spots.    

The plot developed from the SVD analysis of the residuals emphasizes the technical signal in the data. When applied to the spot cell count (SCC) values across multiple arrays, the plots show areas of consistently high or low cell counts.  

```{r, fig.width=4}

s <- svd(YRelArray)
vDT <- data.table(Value=s$v[,which.max(s$d)], Spot = as.integer(sub(".*_", "",colnames(l3Relm))))
vDT$ArrayRow <- as.integer(ceiling(vDT$Spot/20))
vDT$ArrayColumn <- as.integer((vDT$Spot-1) %% 20 +1)

p <- ggplot(vDT, aes(x=ArrayColumn, y=ArrayRow, fill= Value))+
  geom_tile()+
  scale_fill_gradient(low="white",high="red",oob = scales::squish)+
  ggtitle(bquote(.(x[["Signal"]])~Residual~Maximum~Singular~Value~Eigenvector))+
  xlab("")+ylab("")+
  guides(fill=FALSE)+
  xlim(20.5,.5)+ylim(.5,35.5)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.6)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), plot.title = element_text(size = rel(.8)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.7)),panel.grid.major = element_line(linetype = 'blank'),panel.background = element_rect(fill = "lightgrey"))
suppressWarnings(print(p))

```


```{r}

#Cast to get mel values with Barcode rows and well+Spot+ECMp columns
#Use the names to hold the spot contents
#Coerce missing values to have near 0 proliferation signals
l3RelcB <- data.table(dcast(l3, Barcode~WSE, value.var=paste0(x[["Signal"]],"Rel"),fill = fill))
#Remove the Barcode column and use it as rownames in the matrix
l3Relm <- l3RelcB[,grep("Barcode",colnames(l3RelcB), value=TRUE, invert=TRUE), with=FALSE]
YRelPlate <- matrix(unlist(l3Relm), nrow=nrow(l3Relm), dimnames=list(l3RelcB$Barcode, colnames(l3Relm)))

s <- svd(YRelPlate)
splits <- strsplit2(colnames(l3Relm), split="_")
vDT <- data.table(Value=-s$v[,which.max(s$d)], Well=splits[,1], Spot=as.integer(splits[,2]))
vDT$ArrayRow <- as.integer(ceiling(vDT$Spot/20))
vDT$ArrayColumn <- as.integer((vDT$Spot-1) %% 20 +1)
```


###Analysis of Spot Level Signals over Time

Analysis of Spot Level Signals over Time uses the residuals at the spot level as follows.  
   * Median summarize the cell level data to the spot level.  
   * Create residuals by subtracting the median value of the replicates from each spot value  
   * Create an M matrix of residuals that is `r nrow(YRelArray)` rows by `r ncol(YRelArray)` columns. Each column holds residuals for one spot in all MEMAs.  
   * Plot a time course for each spot  
   
The motivation of this plot is to indicate when a well in a source plate is running low of reagent. While the well has reagents, the residual of the SCC value should be near 0. When a well runs dry, fewer cells will grow on the spots made from that well and the track in the plot below will drop down from 0 and remain low.

<br>
   
```{r SpotTimeCourse}

l3RelcTC <- data.table(dcast(l3, BWL~ESB, value.var=paste0(x[["Signal"]],"Rel"), fill = fill))
#Remove the BWL column and use it as rownames in the matrix
l3Relm <- l3RelcTC[,grep("BWL",colnames(l3RelcTC), value=TRUE, invert=TRUE), with=FALSE]
#Y is a numeric matrix of the raw transformed responses 
#of each spot extracted from the l3 dataset
YRelArray <- matrix(unlist(l3Relm), nrow=nrow(l3Relm), dimnames=list(l3RelcTC$BWL, colnames(l3Relm)))

setkey(l3RelcTC, BWL)
l3RelcTC$PrintOrder <- 1:nrow(l3RelcTC)
l3Relmelt <- melt(l3RelcTC, id.vars=c("BWL","PrintOrder"), measure=patterns("_"),variable.name = "ESB", value.name = paste0(x[["Signal"]],"Rel"))
splits <- strsplit2(l3Relmelt$ESB,split="_")
l3Relmelt$Block <- strsplit2(l3Relmelt$ESB,split="_")[,3]

p <- ggplot(l3Relmelt, aes(x=PrintOrder, y=SCCRel, colour=ESB))+
  geom_smooth(size=.1, se = FALSE)+
  guides(colour=FALSE)+
  ggtitle("SCC Time Course by Spot")
print(p)
ggplotly(p)


p <- ggplot(l3Relmelt, aes(x=PrintOrder, y=SCCRel, colour=Block))+
  geom_smooth(size=.1, se = FALSE)+
  guides(colour=FALSE)+
  ggtitle("SCC Time Course by Pin")
print(p)
ggplotly(p)

```