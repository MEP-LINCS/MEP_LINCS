---
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE)
```


```{r, echo=FALSE}
#Author: Mark Dane, copyright 2015

calcGroupRatios <- function(x,group,signal){
  #browser()
  medianInGroup <- median(x[[signal]][x[[group]]], na.rm=TRUE)
  medianOutGroup <- median(x[[signal]][!x[[group]]], na.rm=TRUE)
  return(medianInGroup/medianOutGroup)
} 

scaleToMedians <- function(x, normBase){
  #browser()
  if(!length(x) == length(normBase)) stop("vector to be normalized and base must be the same length")
xn <- as.numeric(x)/normBase
  return(xn)
}

 
#Set the staining set to be analyzed (SS1|SS2|SS3)
ss <- "SS3"
#Set the cell line to be analyzed (PC3|MCF7|YAPC)
cellLine <- "PC3"
```




```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
library("ggplot2")
library("data.table")
library("MEMA")
library("grid")
library(knitr)
library("gplots")
library("RColorBrewer")


create8WellPseudoImage <- function(DT, pr, prDisplay){
  highThresh = .998
  #move outliers to maximum displayed value
  DT[[pr]][DT[[pr]]>=quantile(DT[[pr]],probs = highThresh,na.rm=TRUE)] <- as.integer(quantile(DT[[pr]],probs = highThresh,na.rm=TRUE))
  p <- ggplot(DT, aes_string(x="ArrayColumn", y="ArrayRow",colour=pr))+
    geom_point(size=1)+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red")+
    guides(colour = guide_legend(prDisplay, keywidth = .5, keyheight = .5))+
    ggtitle(paste("\n\n",prDisplay,"for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.8)),axis.title.x = element_text(size=rel(.5)),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.4)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
}


  create8WellHistograms <- function(DT, pr, prDisplay, binwidth = diff(quantile(DT[[pr]],probs = c(0,.98),na.rm=TRUE))/50, upperProb = .99, ncol = 4) {
    
  p <- ggplot(DT, aes_string(x=pr))+
    geom_histogram(binwidth = binwidth)+
    scale_x_continuous(limits = quantile(DT[[pr]],probs = c(0,upperProb),na.rm=TRUE))+
    ggtitle(paste("\n\n",prDisplay,"in",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab(prDisplay)+
        theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=ncol)
  }
  
  
#Setup colors for Barcode and text in all heatmaps
selDark2 <- colorRampPalette(brewer.pal(8,"Dark2"))
plateCol = selDark2(8)

l1 <- fread(paste0("./",cellLine,"/",ss,"/AnnotatedData/",cellLine,"_",ss,"_Level1.txt"), showProgress = FALSE)
l2 <- fread(paste0("./",cellLine,"/",ss,"/AnnotatedData/",cellLine,"_",ss,"_Level2.txt"), showProgress = FALSE)
l3 <- fread(paste0("./",cellLine,"/",ss,"/AnnotatedData/",cellLine,"_",ss,"_Level3.txt"), showProgress = FALSE)
l4 <- fread(paste0("./",cellLine,"/",ss,"/AnnotatedData/",cellLine,"_",ss,"_Level4.txt"), showProgress = FALSE)
l4$MEP <- paste(l4$ECMp, l4$Ligand, sep="-")


barcodes <- sort(unique(l3$Barcode))

#Set a threshold for filtering wells on their QA score
wellQAThresh <- 0.7

#TODO: Read this from Level 3 data
lthresh <- 0.6

```
---
title: "MEP-LINCS `r cellLine` `r ss` Pilot Analysis"
date: "`r Sys.Date()`"
output: pdf_document
---

##Summary
The MEP-LINCS `r cellLine` `r ss` datasets include four levels of high content imaging data from on Microenvironment Microarrays (MEMAs). After QA filtering, there are `r nrow(l4)` Microenvironment Perturbations (MEPs) that are pairwise combinations of `r length(unique(l4$ECMpAnnotID))` printed ECM proteins and `r length(unique(l4$LigandAnnotID))-1` ligands or growth factors.  

##Introduction
The LINCS Pilot `r cellLine` `r ss` experiment was performed with cells grown in eight 8-well plates. The `r ss` staining set includes, DAPI, `r unique(l4$Endpoint488)` (488nm), `r unique(l4$Endpoint555)` (555nm) and `r unique(l4$Endpoint647)` (647nm). Four color images of the cells at each spot were gathered on an Nikon automated microscope. All data for this staining set comes from the nuclei as defined by the DAPI staining.

Intensity, position and a limited set of morphology data are gatherd for each cell, merged with the experiment metadata, normalized and aggregated. The dataset is organized to the four LINCS imaging categories as follows:

Level 1 - Raw data  
Level 2 - Normalized data  
Level 3 - Normalized data aggregated to the spot level  
Level 4 - Normalized data aggregated to the replicate (MEP) level  

The data merging and analysis is done in R using open source software. 

\newpage

##QA Scoring of the dataset
Each well is scored for even cell seeding according to the count of the DAPI-stained nuclei. A detailed explanation of the QA method is in the supplemental material. In brief, the level 2 and 3 data have cell counts at the spot level and locally-averaged cell counts at the neighborhood level. Both of these parameters are used to score the wells and filter the dataset. QA Scores range from 0 to 1 and represent the proportion of the spots that have at least one cell and are not in low cell count neighborhoods.

The following plots are pseudoimages each MEMA's spot cell count and a histogram of the loess model used for QA scoring. 


```{r Heatmaps_QAScores, echo=FALSE, fig.width=3.7,fig.height=4, eval=TRUE}

for (barcode in barcodes){
  DT <-l3[l3$Barcode==barcode,]
  #Remove the fiducial entries
  setkey(DT,ECMp)
  DT <- DT[!"fiducial"]
  DT <- DT[!"blank"]
  
  p <- create8WellPseudoImage(DT, pr = "SpotCellCount",prDisplay = "Spot Cell Count")
  suppressWarnings(print(p))

  wellScores <- unique(DT[,list(Well, QAScore=sprintf("%.2f",QAScore))])

  p <- ggplot(DT, aes(x=LoessSCC))+
    geom_histogram(binwidth=.04)+
    geom_vline(xintercept=lthresh, colour="blue")+
    geom_text(data=wellScores, aes(label=paste0("QA\n",QAScore)), x = 2, y = 30, size = rel(3), colour="red")+
    ggtitle(paste("\n\n\n\n","QA on Loess Model of Spot Cell Count for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+xlab("Normalized Spot Cell Count")+xlim(0,3)+
    theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), axis.title.x = element_text( size=rel(.5)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), axis.title.y = element_text( size=rel(.5)), plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
  suppressWarnings(print(p))

}

```



```{r Filtering, echo=FALSE}

passedQAWells <- unique(l3[l3$QAScore > wellQAThresh,list(Barcode,Well)])

#Remove failed QA wells
setkey(l1,Barcode,Well)
l1F <- merge(l1,passedQAWells)
setkey(l2,Barcode,Well)
l2F <- merge(l2,passedQAWells)
setkey(l3,Barcode,Well)
l3F <- merge(l3,passedQAWells)

#Remove the high serum, fiducial data and blank
setkey(l1F,Ligand)
l1F <- l1F[!"HighSerum"]
setkey(l1F,ECMp)
l1F <- l1F[!"fiducial"]
l1F <- l1F[!"blank"]
#Remove the high serum and fiducial data
setkey(l2F,Ligand)
l2F <- l2F[!"HighSerum"]
setkey(l2F,ECMp)
l2F <- l2F[!"fiducial"]
l2F <- l2F[!"blank"]


#Create a dataset of spots with greater than 20 cells
l2FSCC <- l2F[l2F$SpotCellCount >= 20]

#Remove the high serum and fiducial data
setkey(l3F,Ligand)
l3F <- l3F[!"HighSerum"]
setkey(l3F,ECMp)
l3F <- l3F[!"fiducial"]
l3F <- l3F[!"blank"]

#Summarize spot level data to MEP level by taking the medians of the parameters
mepNames<-grep("AreaShape|Children|Intensity|SpotCellCount|Loess|EdUPositiveProportion|Population|Neighbors|ReplicateCount|LineageRatio|LigandAnnotID|ECMpAnnotID", x=names(l3F),value=TRUE)

mepKeep<-l3F[,mepNames,with=FALSE]
l4F<-mepKeep[,lapply(.SD,numericMedian),keyby="LigandAnnotID,ECMpAnnotID"]
  
#Merge back in the replicate metadata
mDT <- l3F[,list(CellLine,Ligand,Barcode,Endpoint488,Endpoint555,Endpoint647,EndpointDAPI,ECMp,ReplicateCount),keyby="LigandAnnotID,ECMpAnnotID"]
l4F <- mDT[l4F, mult="first"]

#Add Robust Z Score of the normalized Spot Cell Count
SCCMedian <- median(l4F$SpotCellCount_MedNorm, na.rm=TRUE)
SCCmad <-mad(l4F$SpotCellCount_MedNorm, na.rm=TRUE)
l4F$SpotCellCount_MedNorm_RobustZ <- (l4F$SpotCellCount_MedNorm-SCCMedian)/SCCmad

#Add Robust Z Score of the raw Spot Cell Count
SCCMedian <- median(l4F$SpotCellCount, na.rm=TRUE)
SCCmad <-mad(l4F$SpotCellCount, na.rm=TRUE)
l4F$SpotCellCount_RobustZ <- (l4F$SpotCellCount-SCCMedian)/SCCmad

if (ss == "SS2"){
  #Add Robust Z Score of the Edu Signal
  EduPPMedian <- median(l4F$EduPositiveProportion_MedNorm, na.rm=TRUE)
  EduPPmad <-mad(l4F$EduPositiveProportion_MedNorm, na.rm=TRUE)
  if(EduPPmad == 0) { l4F$EduPP_MedNorm_RobustZ <- 0
  } else {
    l4F$EduPP_MedNorm_RobustZ <- (l4F$EduPositiveProportion_MedNorm-EduPPMedian)/EduPPmad
  }
}

if (ss == "SS3"){
  #Add Robust Z Score of the LineageRatio Signal
  lrMedian <- median(l4F$LineageRatio, na.rm=TRUE)
  lrMad <-mad(l4F$LineageRatio, na.rm=TRUE)
  if(lrMad == 0) { l4F$LineageRatio_RobustZ <- 0
  } else {
    l4F$LineageRatio_RobustZ <- (l4F$LineageRatio-lrMedian)/lrMad
  }

  #Add Robust Z Scores of the normalized lineage ratios
  lrMedian <- median(l4F$LineageRatio_MedNorm, na.rm=TRUE)
  lrMad <-mad(l4F$LineageRatio_MedNorm, na.rm=TRUE)
  if(lrMad == 0) { l4F$LineageRatio_MedNorm_RobustZ <- 0
  } else {
    l4F$LineageRatio_MedNorm_RobustZ <- (l4F$LineageRatio_MedNorm-lrMedian)/lrMad
  }
  
}

```

\newpage

##Filtering
Wells with QA scores below `r wellQAThresh ` and the HighSerum control wells are removed from further analysis of the dataset. After filtering on the well QA score there are `r length(unique(l4F$LigandAnnotID))` ligands in the dataset. 

Each spot represents a MEP that is a pairwise combination of the ECM protein printed at a  spot and the ligand in the solution of the well. The number of replicate MEPs after removing low-quality wells are shown in the supplemental material.


##Spot Cell Count Analysis
The spot cell count analysis uses robust Z scores to identify MEPs with extreme population sizes. First, the count of cells at each spot is normalized by dividing it by the median cell count of all spots in the same plate's high serum well.  The normalized spot cell counts are then summarized by the median of their replicates. The median and mad of the distribution of normalized and summarized values are used to convert to robust Z scores and are shown below. The blue lines at +/- 2 show thresholds for selecting MEPs of interest. Below the distribtion plot are plots with Z scores stratified by ligand and ECM protein. A listing of the MEPs outside of the blue lines is in the supplemental material.

```{r SCCRobustZScores, echo=FALSE, fig.width=8, fig.height=3.5, eval=TRUE}

p <- ggplot(l4F, aes(x=SpotCellCount_MedNorm_RobustZ))+geom_bar(binwidth = .1)+
  geom_vline(xintercept = c(-2,2), colour = "blue")+
  ggtitle(paste("\n\n","MEP Median Normalized Spot Cell Count Robust Z Scores Distribution"))+
  ylab("Count")+xlab("Median Normalized Spot Cell Count Robust Z Scores")+
  theme(strip.text = element_text(size = 5))
suppressWarnings(print(p))

```


```{r SCC_response, fig.width=8,  fig.height=6, echo=FALSE}

p <- ggplot(l4F, aes(x = reorder(Ligand, SpotCellCount_MedNorm_RobustZ, FUN=median), y = SpotCellCount_MedNorm_RobustZ, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("\n\nMEP Median Normalized Spot Cell Count Robust Z Scores by Ligand"))+
  xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))
```

```{r, fig.width=8,  fig.height=3.5, echo=FALSE}
p <- ggplot(l4F, aes(x = reorder(ECMp, SpotCellCount_MedNorm_RobustZ, FUN=median), y = SpotCellCount_MedNorm_RobustZ))+geom_boxplot()+
  ggtitle(paste("\n\nMEP Median Normalized Spot Cell Count Robust Z Scores by ECM Protein"))+
  xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

```

\newpage

##Lineage Marker Analysis

This staining set includes the lineage markers KRT5 which is associated with basal cells and KRT19 which is associated with luminal cells. This analysis evaluates the lineage responses through a ratio of the median intensity of KRT19 to KRT5. 

```{r LineageMarkers, echo=FALSE}

p <- ggplot(l4F, aes(x=Cytoplasm_CP_Intensity_MedianIntensity_KRT5_MedNorm,
                     y = Cytoplasm_CP_Intensity_MedianIntensity_KRT19_MedNorm,
                     colour = Ligand))+
  geom_point(alpha=.5)+
  guides(colour=FALSE)+
  xlab("KRT5")+ylab("KRT19")
print(p)

p <- ggplot(l4F, aes(x=LineageRatio))+
  geom_bar(binwidth = .1)+
  ggtitle("Histogram of Lineage Ratios")
print(p)

p <- ggplot(l4F, aes(x=LineageRatio_RobustZ))+geom_bar(binwidth = .1)+
  geom_vline(xintercept = c(-2,2), colour = "blue")+
  ggtitle(paste("\n\n","MEP Lineage Ratio Robust Z Scores Distribution"))+
  ylab("Count")+xlab("Lineage Ratio Robust Z Scores")+
  theme(strip.text = element_text(size = 5))
suppressWarnings(print(p))

```

```{r, echo=FALSE}

p <- ggplot(l4F, aes(x = reorder(Ligand, LineageRatio, FUN=median), y = LineageRatio, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("\n\nMEP  LineageRatio by Ligand"))+
  xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

p <- ggplot(l4F, aes(x = reorder(ECMpAnnotID, LineageRatio, FUN=median), y = LineageRatio))+geom_boxplot()+
  ggtitle(paste("\n\nMEP LineageRatio by ECM Protein"))+
  xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

```

The ligand-stratified boxplots of the lineage ratios show batch effects likely due to each ligand being in a different well with no replicates. These can also be seen in the following boxplots of the lineage ratios in the control wells.

```{r, echo = FALSE}

#Plot lineage ratios of control wells in each plate
p <- ggplot(l4[l4$Ligand == "HighSerum"], aes(x = reorder(Ligand, LineageRatio, FUN=median), y = LineageRatio, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("\n\nLineageRatio in Control Wells"))+
  xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))


#Plot lineage ratios of control wells in each plate
p <- ggplot(l4[l4$Ligand == "HighSerum"], aes(x = reorder(Ligand, Cytoplasm_CP_Intensity_MedianIntensity_KRT19, FUN=median), y = Cytoplasm_CP_Intensity_MedianIntensity_KRT19, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("\n\nKRT19 Intensity in Control Wells"))+
  xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

#Plot lineage ratios of control wells in each plate
p <- ggplot(l4[l4$Ligand == "HighSerum"], aes(x = reorder(Ligand, Cytoplasm_CP_Intensity_MedianIntensity_KRT5, FUN=median), y = Cytoplasm_CP_Intensity_MedianIntensity_KRT5, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("\n\nKRT 5 Intensity in Control Wells"))+
  #xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))
```
The lineage ratio analysis is rerun using normalized data. The normalized data is calculated by dividing each lineage ratio by the lineage ratio of its corresponding control well.

```{r, echo = FALSE}

p <- ggplot(l4F, aes(x=LineageRatio_MedNorm_RobustZ))+geom_bar(binwidth = .1)+
  geom_vline(xintercept = c(-2,2), colour = "blue")+
  ggtitle(paste("\n\n","MEP Normalized Lineage Ratio Robust Z Scores Distribution"))+
  ylab("Count")+xlab("Normalized Lineage Ratio Robust Z Scores")+
  theme(strip.text = element_text(size = 5))
suppressWarnings(print(p))

p <- ggplot(l4F, aes(x = reorder(Ligand, LineageRatio_MedNorm, FUN=median), y = LineageRatio_MedNorm, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("\n\nMEP Normalized LineageRatio by Ligand"))+
  xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

p <- ggplot(l4F, aes(x = reorder(ECMpAnnotID, LineageRatio_MedNorm, FUN=median), y = LineageRatio_MedNorm))+geom_boxplot()+
  ggtitle(paste("\n\nMEP Normalized LineageRatio by ECM Protein"))+
  xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

```

```{r lineageGating, echo=FALSE, eval=FALSE}
for (ligand in unique(l2F$Ligand)[1:4]){
  DT <- l2F[l2F$Ligand == ligand]
p <- ggplot(DT, aes(x = scale(lscale, Nuclei_CP_Intensity_IntegratedIntensity_Dapi),
                     y = scale(lscale,Cytoplasm_CP_Intensity_MedianIntensity_KRT5),
                              colour = MEP))+
  geom_point(size=1, alpha=.5)+
  facet_wrap(~MEP)+
  ylim(.3,.6)+
    guides(colour=FALSE)
print(p)

p <- ggplot(DT, aes(x = scale(lscale, Nuclei_CP_Intensity_IntegratedIntensity_Dapi),
                     y = scale(lscale,Cytoplasm_CP_Intensity_MedianIntensity_KRT19),
                              colour = MEP))+
  geom_point(size=1, alpha=.5)+
  facet_wrap(~MEP)+
  ylim(.5,.7)+
    guides(colour=FALSE)
print(p)
}


for (MEP in (unique(l2F$MEP)[1:10])){
  setkey(l2F,MEP)
  DT <- l2F[MEP]
  p <- ggplot(DT, aes(x = scale(lscale, Nuclei_CP_Intensity_IntegratedIntensity_Dapi_MedNorm),
                     y = scale(lscale,Cytoplasm_CP_Intensity_MedianIntensity_KRT5_MedNorm),
                              colour = MEP))+
  geom_point(size=2, alpha=1)+
    guides(colour=FALSE)+
    xlab("logicle Total DAPI")+ylab("logicle KRT5")+
    ggtitle(MEP)
  
print(p)

  p <- ggplot(DT, aes(x = log2(Nuclei_CP_Intensity_IntegratedIntensity_Dapi_MedNorm),
                     y = log2(Cytoplasm_CP_Intensity_MedianIntensity_KRT5_MedNorm),
                              colour = MEP))+
  geom_point(size=2, alpha=1)+
    guides(colour=FALSE)+
    xlab("Log2 Total DAPI")+ylab("log2 KRT5")+
    ggtitle(MEP)
print(p)

}


```


```{r, echo=FALSE, eval=TRUE}

p <- ggplot(l4F, aes(x=Nuclei_PA_AreaShape_Neighbors_MedNorm,
                     y = LineageRatio_MedNorm))+
  geom_point(alpha=.5)+
  stat_smooth(method="gam")+
  facet_wrap(~ECMp)+
  xlab("Normalized Number of Neighbors")+ylab("KRT19/KRT5")
print(p)

p <- ggplot(l4F, aes(x=Nuclei_PA_AreaShape_Neighbors_MedNorm,
                     y = LineageRatio_MedNorm))+
  geom_point(alpha=.5)+
  stat_smooth(method="gam")+
  facet_wrap(~Ligand)+
  xlab("Number of Neighbors")+ylab("KRT19/KRT5")
print(p)

```


\newpage

##Unbiased Analysis

The unbiased approach is:  
  Summarize the cell level to the median spot level, then combine replicates to get to the MEP level  
  Select a curated feature vector of MEP raw intensities and morphologies  
  Normalize the feature values by dividing them by their control's value
  Calculate the euclidean distance of each MEP's feature vector to the control feature vector  
  Exclude inactive MEPs by selecting for distances above the 95th percentile  
  Perform hierarchical clustering on the active MEPs 
  
The following heatmaps show the active MEPs based on the entire dataset, the dataset without NID1 and the normalized dataset without NID1. The row color bars and text colors identify the 8 different experiment plates and help show plate batch effects.
  
```{r, fig.height=16}


#Need dataset to be filtered for QA wells and still have HighSerum wells
setkey(l4,Barcode,Well)
l4QA <- merge(l4,passedQAWells)
setkey(l4QA,ECMp)
l4QA <- l4QA[!"blank"]
l4QA <- l4QA[!"fiducial"]

#Get numeric features
fv <- grep("_CP_|_PA_|SpotCellCount|Lineage|MEP$",colnames(l4QA),value=TRUE)

#Remove the normalized features
fv <- grep("Norm|Center_X|Center_Y", fv, value = TRUE, invert = TRUE)
#Create numeric feature vectors
fvDT <- l4QA[,fv,with = FALSE]
#Get medians of high serum numeric features
fvDTHS <- fvDT[grepl("HighSerum", fvDT$MEP)]
hsMedians <- data.frame(t(as.matrix(apply(fvDTHS[,grep("MEP", colnames(fvDTHS),invert=TRUE),with=FALSE],2,median))),MEP="HighSerum", stringsAsFactors = FALSE)
#Replace all HighSerum rows with one row of medians as the last row
fvDT<- rbind(fvDT[!grepl("HighSerum", fvDT$MEP)],hsMedians)

#Normalize the feature vectors to the medians
#to equally weight all features
fvDTNorm <- rbindlist(apply(fvDT[,grep("MEP",colnames(fvDT),invert=TRUE), with=FALSE], 1, scaleToMedians, normBase = hsMedians[,grep("MEP",colnames(fvDT),invert=TRUE)]))

#Calculate the dist matrix with euclidean method
dmm <- as.matrix(dist(fvDTNorm), labels=TRUE)
#Extract the distance to the high serum medians
distHS <- dmm[which(fvDT$MEP == "HighSerum"),]
#Name the distance values
names(distHS) <- fvDT$MEP

#Select the most active by distance from the median control fv
dmmThresh <- quantile(distHS,probs = .95)
activeMEPs <- distHS[distHS>dmmThresh]
#browser()
#Create an active MEP subset matrix of the normalized data
activeFV <- fvDT[fvDT$MEP %in% names(activeMEPs)]
#Remove MEP column and convert to a matrix
activeFVM <- as.matrix(activeFV[,grep("MEP",colnames(activeFV),invert=TRUE), with=FALSE])

#This assignment of names retains the order after matrix coercion
rownames(activeFVM) <- names(activeMEPs)
         
#get the barcode for each MEP and add color bar
#get a datatable with columns of barcode and ligand to merge into 
#activeFVM
 activeFVMDT <- data.table(Ligand =sub("[[:alnum:]]*-{1}","",rownames(activeFVM)), Index = 1:nrow(activeFVM))
 l4MEPs <- unique(l4[,list(Barcode,Ligand)])
 setkey(l4MEPs,"Ligand")
 setkey(activeFVMDT,"Ligand")
 activeLB <- merge(activeFVMDT,l4MEPs)
 setkey(activeLB,"Index")
 activeLB$Barcode <- as.factor(activeLB$Barcode)

#Cluster the active MEPs, scaling the inputs
plot.new()
heatmap.2(activeFVM,scale="column", col = bluered, trace = "none", cexRow=.5, cexCol=.7, key=FALSE, main = paste("Active MEP Feature Vectors"), lmat=rbind(c(5,0,4,0),c(3,1,2,0)), lhei=c(2.0,5.0),
          lwid=c(1.5,0.2,2.5,2.5),mar=c(20,5), RowSideColors=plateCol[activeLB$Barcode], colRow = plateCol[activeLB$Barcode])

```

The next heatmap shows the same analysis run on the dataset after removing NID1.
  
```{r, fig.height=16}

#Get numeric features
fv <- grep("_CP_|_PA_|SpotCellCount|Lineage|MEP$",colnames(l4QA),value=TRUE)
fv <- grep("Norm|Center_X|Center_Y", fv, value = TRUE, invert = TRUE)
#Create numeric feature vectors
fvDT <- l4QA[,fv,with = FALSE]
fvDT <- fvDT[!grepl("NID1", fvDT$MEP)]
#Get medians of high serum numeric features
fvDTHS <- fvDT[grepl("HighSerum", fvDT$MEP)]
hsMedians <- data.frame(t(as.matrix(apply(fvDTHS[,grep("MEP", colnames(fvDTHS),invert=TRUE),with=FALSE],2,median))),MEP="HighSerum", stringsAsFactors = FALSE)
#Replace all HighSerum rows with one row of medians as the last row
fvDT<- rbind(fvDT[!grepl("HighSerum", fvDT$MEP)],hsMedians)

#Normalize the feature vectors to the medians
#to equally weight all features
fvDTNorm <- rbindlist(apply(fvDT[,grep("MEP",colnames(fvDT),invert=TRUE), with=FALSE], 1, scaleToMedians, normBase = hsMedians[,grep("MEP",colnames(fvDT),invert=TRUE)]))

#Calculate the dist matrix with euclidean method
dmm <- as.matrix(dist(fvDTNorm), labels=TRUE)
#Extract the distance to the high serum medians
distHS <- dmm[which(fvDT$MEP == "HighSerum"),]
#Name the distance values
names(distHS) <- fvDT$MEP

#Select the most active by distance from the median control fv
dmmThresh <- quantile(distHS,probs = .95)
activeMEPsF <- distHS[distHS>dmmThresh]

#Create an active MEP subset matrix of the normalized data
activeFVF <- fvDT[fvDT$MEP %in% names(activeMEPsF)]
#Remove MEP column and convert to a matrix
activeFVMF <- as.matrix(activeFVF[,grep("MEP",colnames(activeFVF),invert=TRUE), with=FALSE])

rownames(activeFVMF) <- names(activeMEPsF)

#get the barcode for each MEP and add color bar
#get a datatable with columns of barcode and ligand to merge into 
#activeFVM
 activeFVMFDT <- data.table(Ligand =sub("[[:alnum:]]*-{1}","",rownames(activeFVMF)), Index = 1:nrow(activeFVMF))
 setkey(activeFVMFDT,"Ligand")
 activeLB <- merge(activeFVMFDT,l4MEPs)
 setkey(activeLB,"Index")
 activeLB$Barcode <- as.factor(activeLB$Barcode)

        
#Cluster the active MEPs, scaling the inputs
plot.new()
heatmap.2(activeFVMF,scale="column", col = bluered, trace = "none", cexRow=.5, cexCol=.7, key=FALSE, main = paste("Active MEP Feature Vectors\n(no NID1)"),  lmat=rbind(c(5,0,4,0),c(3,1,2,0)), lhei=c(2.0,5.0),
          lwid=c(1.5,0.2,2.5,2.5),mar=c(20,5), RowSideColors=plateCol[activeLB$Barcode], colRow = plateCol[activeLB$Barcode])

```


The next heatmap shows the same analysis run on the dataset after removing NID1 and using data normalized to each plate's control well.
  
```{r, fig.height=16}
setkey(l4F, "ECMp")
l4fv <- l4F[!"blank"]
l4fv <- l4fv[!"fiducial"]
l4fv$MEP <- paste(l4fv$ECMp, l4fv$Ligand, sep="-")

#Get the normalized numeric features
fv <- grep("MedNorm|MEP$",colnames(l4QA),value=TRUE)
fv <- grep("Center_X|Center_Y|SpotNorm", fv, value = TRUE, invert = TRUE)

#Create numeric feature vectors
fvDT <- l4QA[,fv,with = FALSE]
fvDT <- fvDT[!grepl("NID1", fvDT$MEP)]
#Get medians of high serum numeric features
fvDTHS <- fvDT[grepl("HighSerum", fvDT$MEP)]
hsMedians <- data.frame(t(as.matrix(apply(fvDTHS[,grep("MEP", colnames(fvDTHS),invert=TRUE),with=FALSE],2,median))),MEP="HighSerum", stringsAsFactors = FALSE)
#Replace all HighSerum rows with one row of medians as the last row
fvDT<- rbind(fvDT[!grepl("HighSerum", fvDT$MEP)],hsMedians)

#Normalize the feature vectors to the medians
#to equally weight all features
fvDTNorm <- rbindlist(apply(fvDT[,grep("MEP",colnames(fvDT),invert=TRUE), with=FALSE], 1, scaleToMedians, normBase = hsMedians[,grep("MEP",colnames(fvDT),invert=TRUE)]))

#Calculate the dist matrix with euclidean method
dmm <- as.matrix(dist(fvDTNorm), labels=TRUE)
#Extract the distance to the high serum medians
distHS <- dmm[which(fvDT$MEP == "HighSerum"),]
#Name the distance values
names(distHS) <- fvDT$MEP

#Select the most active by distance from the median control fv
dmmThresh <- quantile(distHS,probs = .95)
activeMEPsFN <- distHS[distHS>dmmThresh]

#Create an active MEP subset matrix of the normalized data
activeFVFN <- fvDT[fvDT$MEP %in% names(activeMEPsFN)]
#Remove MEP column and convert to a matrix
activeFVMFN <- as.matrix(activeFVFN[,grep("MEP",colnames(activeFVFN),invert=TRUE), with=FALSE])
rownames(activeFVMFN) <- names(activeMEPsFN)
 
#get the barcode for each MEP and add color bar
#get a datatable with columns of barcode and ligand to merge into 
#activeFVM
 activeFVMFNDT <- data.table(Ligand =sub("[[:alnum:]]*-{1}","",rownames(activeFVMFN)), Index = 1:nrow(activeFVMFN))
 setkey(activeFVMFNDT,"Ligand")
 activeLB <- merge(activeFVMFNDT,l4MEPs)
 setkey(activeLB,"Index")
 activeLB$Barcode <- as.factor(activeLB$Barcode)


#Cluster the active MEPs, scaling the inputs
plot.new()
heatmap.2(activeFVMFN,scale="column", col = bluered, trace = "none", cexRow=.5, cexCol=.7, key=FALSE, main = paste("Active Normalized MEP Feature Vectors\n(no NID1)"), lmat=rbind(c(5,0,4,0),c(3,1,2,0)), lhei=c(2.0,5.0),
          lwid=c(1.5,0.2,2.5,2.5),mar=c(20,5), RowSideColors=plateCol[activeLB$Barcode], colRow = plateCol[activeLB$Barcode])
```


###PCA Unbiased Analysis  
The unbiased analysis is extended by using Principal Component Analysis (PCA) to reduce the dimensions of the feature vector.

The unbiased PCA analysis method is:

  Summarize the cell level to the median spot level, then combine replicates to get to the MEP level  
  Normalize the feature values by dividing them by their control's value
  Use PCA to transform the entire feature set to a much smaller number of principal components (PCFV)
  Calculate the euclidean distance of each MEP's PCFV to the high serum control PCFV 
  Exclude inactive MEPs by selecting for distances above the 95th percentile  
  Perform hierarchical clustering PCFVs of the active MEPs 
  

```{r, fig.height=12}

l4fv <- copy(l4QA)

#Convert Barcode, ECMp, Ligand to factors so they can be used in #colors
l4fv$Barcode <- as.factor(l4fv$Barcode)
l4fv$ECMp <- as.factor(l4fv$ECMp)
l4fv$Ligand <- as.factor(l4fv$Ligand)

#Get the normalized numeric features
fv <- grep("MedNorm|MEP$",colnames(l4QA),value=TRUE)
fv <- grep("Center_X|Center_Y|SpotNorm", fv, value = TRUE, invert = TRUE)
l4fv <- l4fv[,fv, with = FALSE]

#Get the PCFVs
l4PCAModel <- prcomp(as.formula(paste(" ~ ",paste(grep("MedNorm",colnames(l4fv),value=TRUE),collapse = "+"))),data = l4fv, scale= TRUE)
#Test how many to keep using Kaiser’s criterion of variance >1
# (l4PCAModel$sdev)^2 shows keeping 6 PCA. Large drop off after PC 9
#so extending to 9 pcs

#Extract the first 9 PCs of each MEP into a matrix
l4pcv <- l4PCAModel$x[,1:9]

#Get medians of high serum PCs
l4pcvHS <- l4pcv[grepl("HighSerum", l4fv$MEP),]
hsMedians <- data.frame(t(as.matrix(apply(l4pcvHS,2,median))))

#Replace all HighSerum rows with one row of medians as the last row
l4pcvDT<- rbind(l4pcv[!grepl("HighSerum", l4fv$MEP),],hsMedians)

#Calculate the dist matrix with euclidean method
dmm <- as.matrix(dist(l4pcvDT), labels=TRUE)
#Extract the distance to the last row which is the high serum medians
distHS <- dmm[nrow(dmm),]
#Name the distance values
names(distHS) <- c(l4fv$MEP[!grepl("HighSerum", l4fv$MEP)],"HighSerum")

#Select the most active by distance from the median control fv
dmmThresh <- quantile(distHS,probs = .95)
activeMEPsPC <- distHS[distHS>dmmThresh]

#Create an active MEP subset matrix of the PC values
activePC <- l4pcv[l4fv$MEP %in% names(activeMEPsPC),]
#Remove MEP column and convert to a matrix
activeFVMFN <- as.matrix(activeFVFN[,grep("MEP",colnames(activeFVFN),invert=TRUE), with=FALSE])
rownames(activePC) <- names(activeMEPsPC)
 
#get the barcode for each MEP and add color bar
#get a datatable with columns of barcode and ligand to merge into 
#activePC
 activePCDT <- data.table(Ligand =sub("[[:alnum:]]*-{1}","",rownames(activePC)), Index = 1:nrow(activePC))
 setkey(activePCDT,"Ligand")
 activeLB <- merge(activePCDT,l4MEPs)
 setkey(activeLB,"Index")
 activeLB$Barcode <- as.factor(activeLB$Barcode)


 #Cluster the active MEPs, scaling the inputs
plot.new()
heatmap.2(activePC,scale="column", col = bluered, trace = "none", cexRow=.5, cexCol=.7, key=FALSE, main = paste("Active PCA MEPs"), lmat=rbind(c(5,0,4,0),c(3,1,2,0)), lhei=c(2.0,5.0),
          lwid=c(1.5,0.2,2.5,2.5),mar=c(20,5), RowSideColors=plateCol[activeLB$Barcode], colRow = plateCol[activeLB$Barcode])

```

####PCA Without NID1

```{r, fig.height=3,fig.width=4}
l4fv <- copy(l4QA)
setkey(l4F, "ECMp")
l4fv <- l4fv[!"NID1"]
l4fvMD <- copy (l4fv)

#Convert Barcode, ECMp, Ligand to factors so they can be used in #colors
l4fvMD$Barcode <- as.factor(l4fvMD$Barcode)
l4fvMD$ECMp <- as.factor(l4fvMD$ECMp)
l4fvMD$Ligand <- as.factor(l4fvMD$Ligand)

#Get the normalized numeric features
fv <- grep("MedNorm|MEP$",colnames(l4fvMD),value=TRUE)
fv <- grep("Center_X|Center_Y|SpotNorm", fv, value = TRUE, invert = TRUE)
l4fv <- l4fv[,fv, with = FALSE]

#Get the PCFVs
l4PCAModel <- prcomp(as.formula(paste(" ~ ",paste(grep("MedNorm",colnames(l4fv),value=TRUE),collapse = "+"))),data = l4fv, scale= TRUE)
#Test how many to keep using Kaiser’s criterion of variance >1
# (l4PCAModel$sdev)^2 shows keeping 6 PCA. Large drop off after PC 9
#so extending to 9 pcs

 
plot(l4PCAModel, main  = paste("PCA Scree Plot for",cellLine,ss), type = "lines")
abline(h = 1, col = "blue")
title(xlab = "Principal Component")

p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC2, col = l4fvMD$Barcode)) +
  geom_point(size = rel(.8), alpha = .8) +
  labs(colour = "Barcode")+
  theme(legend.text=element_text(size = 6))+
  guides(colour = guide_legend(override.aes = list(size=6)))
print(p)

p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC3, col = l4fvMD$Barcode)) +
  geom_point(size = rel(.8), alpha = .8) +
  labs(colour = "Barcode")+
  theme(legend.text=element_text(size = 6))+
  guides(colour = guide_legend(override.aes = list(size=6)))
print(p)

p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC2, y = PC3, col = l4fvMD$Barcode)) +
  geom_point(size = rel(.8), alpha = .8) +
  labs(colour = "Barcode")+
  theme(legend.text=element_text(size = 6))+
  guides(colour = guide_legend(override.aes = list(size=6)))
print(p)

p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC2, col = l4fv$Nuclei_CP_AreaShape_Area_MedNorm)) +
  geom_point(size = rel(.8), alpha = .8) +
  labs(colour = "Nuclei Area")+
  theme(legend.text=element_text(size = 6))+
  guides(colour = guide_legend(override.aes = list(size=6)))
print(p)


p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC2, col = l4fv$Cytoplasm_CP_Intensity_MedianIntensity_KRT19_MedNorm)) +
  geom_point(size = rel(.8), alpha = .8) +
  labs(colour = "KRT19")+
  theme(legend.text=element_text(size = 6))+
  guides(colour = guide_legend(override.aes = list(size=6)))
print(p)

p <- ggplot(data.frame(l4PCAModel$x), aes(x = PC1, y = PC9, col = l4fv$SpotCellCount_MedNorm)) +
  geom_point(size = rel(.8), alpha = .8) +
  labs(colour = "Spot Cell Count")+
  theme(legend.text=element_text(size = 6))+
  guides(colour = guide_legend(override.aes = list(size=6)))
print(p)

kable(l4PCAModel$rotation[,1:9], digits = 2)

#Extract the first 9 PCs of each MEP into a matrix
l4pcv <- l4PCAModel$x[,1:9]

#Get medians of high serum PCs
l4pcvHS <- l4pcv[grepl("HighSerum", l4fv$MEP),]
hsMedians <- data.frame(t(as.matrix(apply(l4pcvHS,2,median))))

#Replace all HighSerum rows with one row of medians as the last row
l4pcvDT<- rbind(l4pcv[!grepl("HighSerum", l4fv$MEP),],hsMedians)

#Calculate the dist matrix with euclidean method
dmm <- as.matrix(dist(l4pcvDT), labels=TRUE)
#Extract the distance to the last row which is the high serum medians
distHS <- dmm[nrow(dmm),]
#Name the distance values
names(distHS) <- c(l4fv$MEP[!grepl("HighSerum", l4fv$MEP)],"HighSerum")

#Select the most active by distance from the median control fv
dmmThresh <- quantile(distHS,probs = .95)
activeMEPsPC <- distHS[distHS>dmmThresh]

#Create an active MEP subset matrix of the PC values
activePC <- l4pcv[l4fv$MEP %in% names(activeMEPsPC),]
#Remove MEP column and convert to a matrix
activeFVMFN <- as.matrix(activeFVFN[,grep("MEP",colnames(activeFVFN),invert=TRUE), with=FALSE])
rownames(activePC) <- names(activeMEPsPC)
 
#get the barcode for each MEP and add color bar
#get a datatable with columns of barcode and ligand to merge into 
#activePC
 activePCDT <- data.table(Ligand =sub("[[:alnum:]]*-{1}","",rownames(activePC)), Index = 1:nrow(activePC))
 setkey(activePCDT,"Ligand")
 activeLB <- merge(activePCDT,l4MEPs)
 setkey(activeLB,"Index")
 activeLB$Barcode <- as.factor(activeLB$Barcode)
```

```{r, fig.height=12, fig.width=8} 
#Cluster the active MEPs, scaling the inputs
plot.new()
heatmap.2(activePC,scale="column", col = bluered, trace = "none", cexRow=.5, cexCol=.7, key=FALSE, main = paste("Active PCA MEPs\n(no NID1)"), lmat=rbind(c(5,0,4,0),c(3,1,2,0)), lhei=c(2.0,5.0),
          lwid=c(1.5,0.2,2.5,2.5),mar=c(20,5), RowSideColors=plateCol[activeLB$Barcode], colRow = plateCol[activeLB$Barcode])

```


\newpage

#Supplemental Material


##MEMA Layout
All MEMAs in the experiment are in separate wells and have the same design of 46 ECM proteins spotted in 35 rows and 20 columns. The proteins are randomly assigned to spots in the top 30 rows. Rows 31-35 are replicates of rows 1-5. The upper left and bottom right corners of each MEMA are image fiducials in the 488nm channel and there are four blank spots for checking orientation in all channels.   

```{r Content Layout,echo=FALSE, message=FALSE, warnings=FALSE, fig.width=6}

#Select the A row wells and delete the blanks
setkey(l1,Well)
DT <- unique(l1[grep("A",unique(l1$Well),value=TRUE),list(ArrayRow,ArrayColumn,ECMp)])
setkey(DT,ECMp)
DT <- DT[!"blank"]

p <- ggplot(DT,aes(x = ArrayColumn, y = ArrayRow, fill=ECMp))+
  geom_point(shape=21, size = 2.2)+
  guides(fill=guide_legend(ncol = 4))+
  theme(legend.text = element_text(size = rel(.5)),legend.title=element_text(size = rel(.5)),plot.title=element_text(size = rel(.8)))+
  scale_y_reverse()+
  xlab("")+ylab("")+
  ggtitle(" \n\nLINCS MEMA A Row Layout")
print(p)

```


##Replicate Count
The MEMAs have an average of 15 replicates with a range from 13 to 19.  

```{r Layout Replicate Count,echo=FALSE, message=FALSE, warnings=FALSE, fig.width=6.5, fig.height=3}
#Remove the fiducial and blank entries
setkey(DT,ECMp)
DT <- DT[!"fiducial"]
DT <- DT[!"blank"]


p <- ggplot(DT, aes(x=ECMp))+
  geom_bar(width=.8)+geom_hline(yintercept = mean(table(DT$ECMp)), colour="blue")+
  ggtitle(" \n\nCount of Replicate ECM Proteins In Each MEMA")+
  xlab("Printed ECM Protein")+ylab("Number of spots")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),axis.title.x = element_text(size=rel(.8)),axis.title.y = element_text(size=rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)))

print(p)

```

##Quality Analysis
The variance of the signal in MEMA data comes from biological and technical factors. The technical factors create regions of low cell counts per spot and uneven staining across the array. The goal of the QA pipeline is to quantify the technical factors to identify wells or plates that need to be removed from downstream processing and/or be replaced by wells from a new experiment.

The hypothesis for the MEMA QA process is that the biological signal comes from individual spots while the technical variations come from regions of low signal. A bivariate loess model can be used to quantify the number of spots in low signal regions, leading to a MEMA QA score. 
\newpage

###Loess Model Explanation
The loess model of a MEMA is the mean value of a weighted version of each spot's region or neighborhood. In a 700 spot array, a loess span value of 0.1 sets the size of the neighborhood to be the nearest 70 points (within approximately 5 spots in all directions). The weights are a tricubic function of the euclidean distance between the spot being modeled and the neighborhood spots. These weights vary from 1 to 0 as distances increase from the nearest to the farthest neighbor. In other words, each spot in the model takes on the mean value of its 70 nearest neighbors with the closest neighbors having the largest impact. Therefore, the loess model is dominated by the technical regional factors as opposed to individual biological responses.

A MEMA's QA score is derived from the loess model of the control-well-normalized values by calculating the proportion of spots in low signal regions(LSR). A threshold for classifying spots as LSR is based on the median of each plate's control well. To have higher scores reflect increasing quality, the MEMA QA score is defined as the proportion of non-LSR spots to total spots. This value will be 1 for MEMAs with no low signal regions and approach 0 as the number of LSR spots increases.

Below are plots showing data from well B01 from plate LI8X00110 from LINCS staining set 2. The LSR spots are those to the left of the blue vertical line at the threshold value of `r lthresh ` in the histogram. 


```{r Loess_Model_explanation , echo=FALSE, fig.width=2.5,fig.height=4}
setkey(l3,Barcode,Well)
DT <-l3[.(barcodes[1],"A01")]
#Remove the fiducial entries
setkey(DT,ECMp)
DT <- DT[!"fiducial"]
DT <- DT[!"blank"]

p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=SpotCellCount))+
  geom_point(size=1.8)+
  scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
  scale_colour_gradient(low = "white", high = "red")+
  guides(colour = guide_legend("Spot Cell\nCount", keywidth = .5, keyheight = .5))+
  ggtitle(paste("\n\n","Spot Cell Count for",unique(DT$CellLine), "cells \nin plate",unique(DT$Barcode)))+
  xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=LoessSCC))+
  geom_point(size=1.8)+
  scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
  scale_colour_gradient(low = "white", high = "red")+
  guides(colour = guide_legend("Normalized \nSpot Cell \nCount", keywidth = .5, keyheight = .5))+
  ggtitle(paste("\n\n","Loess Model of Spot Cell Count \nfor",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
  xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

  DT <- DT[,QAScore := calcQAScore(.SD,threshold=lthresh,value="LoessSCC"),by="Well"]
  wellScores <- unique(DT[,list(Well,QAScore=sprintf("%.2f",QAScore))])

  p <- ggplot(DT, aes(x=LoessSCC))+
  geom_histogram(binwidth=.02)+
  geom_vline(xintercept=lthresh, colour="blue")+
  geom_text(data=wellScores, aes(label=paste0("QA\n",QAScore)), x = .9, y = 30, size = rel(5), colour="red")+
  ggtitle(paste("\n\n","Loess Model of Spot Cell Count \nfor",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+xlab("Spot Cell Count")+
  theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))


```

\newpage

##Replicates after filtering

```{r FilteredReplicateCount,echo=FALSE, message=FALSE, warnings=FALSE, fig.width=6.5, fig.height=5}

p <- ggplot(l4F, aes(x = ECMp, y=ReplicateCount))+
  geom_boxplot()+
  ggtitle(" \n\nCount of MEP Replicates by ECM Protein")+
  xlab("")+ylab("Replicate Count")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),axis.title.x = element_text(size=rel(.8)),axis.title.y = element_text(size=rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)))

print(p)

p <- ggplot(l4F, aes(x = Ligand, y=ReplicateCount))+
  geom_boxplot()+
  ggtitle(" \n\nCount of MEP Replicates by Ligand")+
  xlab("")+ylab("Replicate Count")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),axis.title.x = element_text(size=rel(.8)),axis.title.y = element_text(size=rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)))

print(p)

```

\newpage

##Stain Pseudoimages
The pseudoimages of each well's raw signals are shown in the plots below. Wells that could not be sucessfully imaged due to focus issues are missing from the pseudoimages.

```{r Pseudoimages_all_stains, echo=FALSE, fig.width=3.7,fig.height=4, eval=TRUE}

for (barcode in barcodes){
  DT <-l3[l3$Barcode==barcode,]
  #Remove the fiducial entries
  setkey(DT,ECMp)
  DT <- DT[!"fiducial"]
  DT <- DT[!"blank"]
  
  p <- create8WellPseudoImage(DT, pr = "Nuclei_CP_Intensity_MedianIntensity_Dapi", prDisplay = "Median DAPI")
  suppressWarnings(print(p))
  
  p <- create8WellPseudoImage(DT, pr = "Cytoplasm_CP_Intensity_MedianIntensity_KRT5", prDisplay = unique(DT$Endpoint488))
  suppressWarnings(print(p))
  
    p <- create8WellPseudoImage(DT, pr = "Cytoplasm_CP_Intensity_MedianIntensity_KRT19",prDisplay = unique(DT$Endpoint555))
  suppressWarnings(print(p))
  
  p <- create8WellPseudoImage(DT, pr = "Cytoplasm_CP_Intensity_MedianIntensity_CellMask",prDisplay = unique(DT$Endpoint647))
  suppressWarnings(print(p))
  
}

```

\newpage

```{r SCCHighSerum_response}

p <- ggplot(l3[l3$Ligand == "HighSerum"], aes(x = reorder(Ligand, SpotCellCount, FUN=median), y = SpotCellCount, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("\n\nSpot Cell Count in High Serum Wells"))+
  xlab("")+ylab("")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

```

\newpage

###Extreme Spot Cell Count MEPs

```{r SCCMeps,echo=FALSE, fig.width=8, fig.height=5, eval=TRUE}

setkey(l4F, SpotCellCount_MedNorm_RobustZ)
kable(l4F[l4F$SpotCellCount_MedNorm_RobustZ >=2| 
            l4F$SpotCellCount_MedNorm_RobustZ <=-2, list(Ligand,ECMp,SpotCellCount_MedNorm_RobustZ, SpotCellCount)],digits = 2)
```

\newpage

###Active MEPS from Unbiased Analysis
The table below shows the active MEPs and their euclidean distance from the feature vector of the control wells (High serum wells).

```{r ActiveMeps, echo = FALSE}
activeMEPs <- activeMEPs[order(activeMEPs)]
kable(activeMEPs, digits = 2)

```

###Active MEPS w/o NID1
The table below shows the active MEPs (without NID1) and their euclidean distance from the feature vector of the control wells (High serum wells).

```{r ActiveMepsNoNID, echo = FALSE}
activeMEPsF <- activeMEPsF[order(activeMEPsF)]
kable(activeMEPsF, digits = 2)

```

###Active Median Normalized MEPS w/o NID1
The table below shows the active MEPs (without NID1) based on their normalized feature vectors and their euclidean distance from the feature vector of the control wells (High serum wells).

```{r ActiveMepsNormedNoNID, echo = FALSE}
activeMEPsFN <- activeMEPsFN[order(activeMEPsFN)]
kable(activeMEPsFN, digits = 2)

```

\newpage

##Cell Cycle Plots
Cell Cycle plots include univariate plots of the total DAPI signal.

```{r Cell_cycle_plots,echo=FALSE, fig.width=8, fig.height=5, eval=TRUE}

for (barcode in barcodes){
  mDT <- l1[l1$Barcode == barcode]
  mDT <- mDT[mDT$Nuclei_CP_Intensity_IntegratedIntensity_Dapi > quantile(mDT$Nuclei_CP_Intensity_IntegratedIntensity_Dapi, probs=.01, na.rm=TRUE) & mDT$Nuclei_CP_Intensity_IntegratedIntensity_Dapi < quantile(mDT$Nuclei_CP_Intensity_IntegratedIntensity_Dapi,probs=.98, na.rm=TRUE)]
  p <- ggplot(mDT, aes(x=Nuclei_CP_Intensity_IntegratedIntensity_Dapi))+geom_bar(binwidth = 2)+
    facet_wrap(~Ligand, nrow=2, scales="free_x")+
    #xlim(0,quantile(mDT$TotalIntensityDAPI,probs=.98, na.rm=TRUE))+
    ggtitle(paste("\n\n","Total DAPI Signal,",barcode))+
    ylab("Count")+xlab("Total Intensity DAPI")+
    theme(strip.text = element_text(size = 5))
  suppressWarnings(print(p))
}

if (ss == "SS1"){
  
  
} else if (ss == "SS2"){
  
} 
```



```{r Perimeter_Median_Ratios, echo=FALSE,fig.width=8, eval=FALSE}


if(ss=="SS1"){
  
l2 <- l2[, MitoPerimeterRatio := calcGroupRatios(.SD,group="Perimeter",signal="MeanIntensityAlexa647MedNorm"), by="Ligand,ECMp"]

l2 <- l2[, MitoSparseRatio := calcGroupRatios(.SD,group="Sparse",signal="MeanIntensityAlexa647MedNorm"), by="Ligand,ECMp"]


setkey(l2,MitoPerimeterRatio)
MEP <- unique(l2[,list(ECMp,Ligand,MitoPerimeterRatio,MitoSparseRatio,Barcode,Well,ArrayRow,ArrayColumn,SpotCellCount,MeanIntensityAlexa647SpotNorm)])

p <- ggplot(l2, aes(x=factor(Perimeter), y=log2(MeanIntensityAlexa647MedNorm)))+geom_boxplot(notch=TRUE)+
      xlab("Perimeter")+ylab(paste(unique(l2$Endpoint647), "Mean Intensity (log2)"))+
    ggtitle(paste("\n\n",unique(l2$Endpoint647), "Mean Intensity in Interior vs. Perimeter Cells"))
  suppressWarnings(print(p))
  
  p <- ggplot(l2, aes(x=factor(Sparse), y=log2(MeanIntensityAlexa647MedNorm)))+geom_boxplot(notch=FALSE)+
    xlab("Sparse")+ylab(paste(unique(l2$Endpoint647), "Mean Intensity (log2)"))+
    ggtitle(paste("\n\n",unique(l2$Endpoint647), "Mean Intensity in Dense vs. Sparse Cells"))
  suppressWarnings(print(p))
  
  p <- ggplot(l2, aes_string(x="factor(ECMp)",y=paste0("MitoPerimeterRatio"), colour="Ligand"))+geom_point(size=3)+
    ggtitle(paste("\n\n","Perimeter vs Interior Ratios in ",unique(l2$Endpoint647), "Signal by MEP"))+
    ylab(paste(unique(l2$Endpoint647),"Perimeter to Interior Ratio"))+xlab("")+
    theme(strip.text = element_text(size = 5), axis.text.x = element_text(angle = 90),
          axis.ticks.x = element_blank())
  suppressWarnings(print(p))
  
} else if (ss=="SS2"){

l2 <- l2[, EdUPerimeterRatio := calcGroupRatios(.SD,group="Perimeter",signal="MeanIntensityAlexa647MedNorm"), by="Ligand,ECMp"]

l2 <- l2[, EdUSparseRatio := calcGroupRatios(.SD,group="Sparse",signal="MeanIntensityAlexa647MedNorm"), by="Ligand,ECMp"]


}

```

```{r EdU_Perimeter_1st, echo=FALSE,fig.width=8, fig.height=11, eval=FALSE}
nrLigands <- length(unique(l2$Ligand))
for(ligand in unique(l2$Ligand)[1:floor(nrLigands/2)]){
  mDT <- l2[l2$Ligand == ligand]
  p <- ggplot(mDT, aes(x=1,y=log2(MeanIntensityAlexa647SpotNorm), colour=Perimeter))+geom_boxplot(notch=FALSE)+
  facet_wrap(~ECMp, nrow=3)+
    ylim(-4,4)+
    ggtitle(paste("\n\n","Perimeter vs Interior",unique(mDT$Endpoint647), "Signal for",ligand, "Paired MEPs"))+
    ylab(paste("Spot Normalized",unique(mDT$Endpoint647)))+xlab("")+
    theme(strip.text = element_text(size = 5), axis.text.x = element_blank(),
          axis.ticks.x = element_blank())
  suppressWarnings(print(p))
}
```

```{r EdU_Perimeter_2nd, echo=FALSE,fig.width=8, fig.height=10, eval=FALSE}

for(ligand in unique(l2$Ligand)[floor(nrLigands/2):nrLigands]){
  mDT <- l2[l2$Ligand == ligand]
  p <- ggplot(mDT, aes(x=1,y=log2(MeanIntensityAlexa647SpotNorm), colour=Perimeter))+geom_boxplot(notch=FALSE)+
  facet_wrap(~ECMp, nrow=3)+
    ylim(-4,4)+
    ggtitle(paste("\n\n","Perimeter vs Interior",unique(mDT$Endpoint647), "Signal for",ligand, "Paired MEPs"))+
    ylab(paste("Spot Normalized",unique(mDT$Endpoint647)))+xlab("")+
    theme(strip.text = element_text(size = 5), axis.text.x = element_blank(),
          axis.ticks.x = element_blank())
  suppressWarnings(print(p))
}
```
