
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE, cache=FALSE)

```

```{r setup, cache=FALSE}
#Author: Mark Dane, copyright 2016

library(parallel)
library(randomForest)
library(class)
library("ggplot2")
library(scales)
library("data.table")
library("MEMA")
library("grid")
library("knitr")
library("gplots")
library("RColorBrewer")
library(DT)
library(d3heatmap)
library(plotly)
library(tidyr)
source("MEPLINCSFunctions.R")
```


```{r specificFunctions}
create8WellPseudoImage <- function(DT, pr, prDisplay,highThresh = .99, lowThresh = .01, highThreshValue=NULL, lowThreshValue=NULL){
  #find high and low values
  if(is.null(highThreshValue)) highThreshValue<-quantile(DT[[pr]],probs = highThresh,na.rm=TRUE)
  if(is.null(lowThreshValue)) lowThreshValue<-quantile(DT[[pr]],probs = lowThresh,na.rm=TRUE)
  p <- ggplot(DT, aes_string(x="ArrayColumn", y="ArrayRow",colour=pr))+
    geom_point(size=rel(.25))+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red", limits=c(lowThreshValue, highThreshValue), oob=squish)+
    guides(colour = guide_legend(prDisplay, keywidth = .5, keyheight = .5))+
    ggtitle(paste(prDisplay,"\n",unique(DT$CellLine), "cells\nplate",unique(DT$Barcode)))+
    xlab("")+ylab("")+
    theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.8)),
          axis.title.x = element_text(size=rel(.5)),
          plot.title = element_text(size = rel(.8)),
          strip.text = element_text(size = rel(.5)),
          legend.text=element_text(size = rel(.4)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well_Ligand, ncol=4)
}
create8WellPseudoImageTriColor <- function(DT, pr, prDisplay,highThresh = .99, lowThresh = .01, highThreshValue=NULL, lowThreshValue=NULL){
  #find high and low values
  if(is.null(highThreshValue)) highThreshValue<-quantile(DT[[pr]],probs = highThresh,na.rm=TRUE)
  if(is.null(lowThreshValue)) lowThreshValue<-quantile(DT[[pr]],probs = lowThresh,na.rm=TRUE)
  p <- ggplot(DT, aes_string(x="ArrayColumn", y="ArrayRow",colour=pr))+
    geom_point(size=rel(.25))+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_distiller(palette="RdBu",limits=c(lowThreshValue, highThreshValue), oob=squish)+
    guides(colour = guide_legend(prDisplay, keywidth = .5, keyheight = .5))+
    ggtitle(paste(prDisplay,"\n",unique(DT$CellLine), "cells \nplate",unique(DT$Barcode)))+
    xlab("")+ylab("")+
    theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.8)),
          axis.title.x = element_text(size=rel(.5)),
          plot.title = element_text(size = rel(.8)),
          strip.text = element_text(size = rel(.5)),
          legend.text=element_text(size = rel(.4)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well_Ligand, ncol=4)
}

```


```{r readProcessData}

#Setup colors for Barcode and text in all heatmaps
selDark2 <- colorRampPalette(brewer.pal(8,"Dark2"))
plateCol = selDark2(8)
hmcols<-colorRampPalette(c("blue","white","red"))(16)
cellLine<-"HMEC122L"
ss<-"SS4"
verbose<-TRUE
devel<- TRUE

slDT <- shortenHA(fread(paste0("../AnnotatedData/",cellLine, "_",ss,"_Level3.txt"), showProgress = FALSE))
slDT$OmeroDetailURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/img_detail/',slDT$ImageID,'/"',' target="_blank">Omero</a>')
slDT$OmeroThumbnailURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/render_thumbnail/',slDT$ImageID,'/"',' target="_blank">Omero</a>')
slDT$OmeroImageURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/render_image/',slDT$ImageID,'/"',' target="_blank">Omero</a>')
slDT <- slDT[,Spot_PA_SpotCellCountRes:=calcResidual(Spot_PA_SpotCellCount),by="Barcode,Well,ECMp"]
slDT$Well_Ligand <- sub("_","\n",slDT$Well_Ligand)
barcodes <- sort(unique(slDT$Barcode))
setkey(slDT,ECMp)
gslDT <- slDT["COL1",]

```

#MEMA Grid Normalization Evaluation
####date: `r Sys.Date()`

##Introduction
The MEP-LINCS MEMAs are printed with `r max(slDT$ArrayRow)` rows and `r max(slDT$ArrayCol)` columns containing a grid of `r sum(slDT$Barcode==unique(slDT$Barcode)[1]&slDT$Well=="A01" & slDT$ECMp=="COL1")` COL1 spots and replicates of `r length(unique(slDT$ECMp))-3` other ECM proteins. This reports evaluates the COL1 grid as a means of removing technical variations from the data. 

Cell Line: `r cellLine`   
Staining set: `r ss` 
Number of 8-well plates: `r length(unique(slDT$Barcode))`  
Endpoints: `r unique(slDT$EndpointDAPI)`, `r unique(slDT$Endpoint488)`, `r unique(slDT$Endpoint555)` and `r unique(slDT$Endpoint647)`.  

<br>

###Spot Cell Count
The first set of figures shows the spot cell count of the COL1 grid.  

```{r rawArrayValues, fig.width=3.7,fig.height=4, eval=TRUE}
setkey(gslDT,Barcode)
lowThreshValue <- quantile(gslDT$Spot_PA_SpotCellCount,probs=.02,na.rm=TRUE)
highThreshValue <- quantile(gslDT$Spot_PA_SpotCellCount,probs=.98,na.rm=TRUE)
for(barcode in barcodes){
  DT <- gslDT[barcode,]
  p <- create8WellPseudoImage(DT, pr = "Spot_PA_SpotCellCount",prDisplay = "Spot Cell Count",lowThreshValue = lowThreshValue, highThreshValue = highThreshValue)
  suppressWarnings(print(p))
}

```

###Spot Cell Count Residuals
The following figures show the residuals after subtracting the median of the COL1 replicates within each well. All figures have the same color scale.    
<br>

```{r SCCResidualArrays, fig.width=3.7,fig.height=4, eval=TRUE}
setkey(gslDT,Barcode)
lowThreshValue <- quantile(gslDT$Spot_PA_SpotCellCountRes,probs=.02,na.rm=TRUE)
highThreshValue <- quantile(gslDT$Spot_PA_SpotCellCountRes,probs=.98,na.rm=TRUE)

for(barcode in barcodes){
  DT <- gslDT[barcode,]
  p <- create8WellPseudoImageTriColor(DT, pr = "Spot_PA_SpotCellCountRes",prDisplay = "Spot Cell Count Residuals",lowThreshValue = lowThreshValue, highThreshValue = highThreshValue)
  suppressWarnings(print(p))
}

```

###Leave One Out Cross Validation
Create and evaluate several types of models for each signal in each well. For each model type, create a set of models that leaves out one of the spots. Then use the model to predict the value of the missing spot. Calculate the Mean Squared Error (MSE) for each model and signal type by comparing the predicted and actual values. 



```{r LOO-CV}
#The dimensions of the data are model, model parameters, signal, array
#Keep the data in lists for efficiency

#Start with model type
modelTypes<-list(list(name="loess",span=c(.2,.5,1)),list(name="randomForest"),list(name="1NN"))
#Start with only SpotCellCount signal
signals <- grep("SpotCellCount$",colnames(gslDT), value=TRUE)
gslDT <- gslDT[,.(Barcode,Well,Ligand,ECMp,MEP,ArrayRow,ArrayColumn,Spot_PA_SpotCellCount,Well_Ligand)]
setnames(gslDT, "Spot_PA_SpotCellCount","value")
gslDT$PrintRow <- gslDT$ArrayRow
gslDT$PrintColumn <- gslDT$ArrayColumn

#Create a wrapper function for modeling with loess
#Return the predicted values from models that leave out each value, one at a time
loessLOO <- function(dt, span=1){
  if(!("PrintRow"%in%colnames(dt)&"PrintColumn"%in%colnames(dt)&"value"%in%colnames(dt)))stop("loess modelingrequires PrintRow, PrintColumn and value columns")
  predictedValue<-unlist(lapply((1:nrow(dt)), function(looRow){
    m <- loess(value~PrintRow+PrintColumn,dt[-looRow,], span=span)
    predict(m,dt[looRow,])
  }))
}

#Create a wrapper function for modeling with random forest
#Return the predicted values from models that leave out each value, one at a time
rfLOO <- function(dt){
  if(!("PrintRow"%in%colnames(dt)&"PrintColumn"%in%colnames(dt)&"value"%in%colnames(dt)))stop("random forest modelingrequires PrintRow, PrintColumn and value columns")
  predictedValue<-unlist(lapply((1:nrow(dt)), function(looRow){
    m <- randomForest(value~PrintRow+PrintColumn,dt[-looRow,])
    predict(m,dt[looRow,])
  }))
}

#Create a wrapper function for modeling with knn
#Return the predicted values from models that leave out each value, one at a time
knnLOO <- function(dt){
  if(!("PrintRow"%in%colnames(dt)&"PrintColumn"%in%colnames(dt)&"value"%in%colnames(dt)))stop("random forest modelingrequires PrintRow, PrintColumn and value columns")
  as.integer(knn.cv(train=dt[,.(PrintRow,PrintColumn)], cl=factor(dt[,value])))
}

#Add the loo loess results and return the span used in the model as part of the column name
addLoessPredictions<-function(dt,span=1){
  loessDT <- rbindlist(lapply(barcodes,function(barcode){
    setkey(dt,Barcode)
    dtb<-dt[barcode,]
    wellDT<-rbindlist(lapply(unique(dtb$Well),function(well){
      setkey(dtb,Well)
      dtbw<-dtb[well,]
      dtbw[[paste0("PredictedLoessValue_",span)]]<-loessLOO(dtbw,span=span)
      return(dtbw)
    }))
  }))
}

#Add the loo random forest results
addRFPredictions<-function(dt){
  rfDT <- rbindlist(lapply(barcodes,function(barcode){
    setkey(dt,Barcode)
    dtb<-dt[barcode,]
    wellDT<-rbindlist(lapply(unique(dtb$Well),function(well){
      setkey(dtb,Well)
      dtbw<-dtb[well,]
      dtbw[[paste0("PredictedRFValue")]]<-rfLOO(dtbw)
      #Add predictions from the full grid
      m <- randomForest(value~PrintRow+PrintColumn,dtbw)
      dtbw$PredictedGridRFValue <- predict(m,dtbw)
      return(dtbw)
    }))
  }))
}


#Add the loo knn results
addknnPredictions<-function(dt){
  knnDT <- rbindlist(lapply(barcodes,function(barcode){
    setkey(dt,Barcode)
    dtb<-dt[barcode,]
    wellDT<-rbindlist(lapply(unique(dtb$Well),function(well){
      setkey(dtb,Well)
      dtbw<-dtb[well,]
      dtbw[[paste0("PredictedknnValue")]]<-knnLOO(dtbw)
      return(dtbw)
    }))
  }))
}

#Create models of each array using all of the COL1 grid spots
#Add the full grid predictions to the dataset
addFGLoessPredictions<-function(dt, span=1){
  DT <- rbindlist(lapply(barcodes,function(barcode){
    setkey(dt,Barcode)
    dtb<-dt[barcode,]
    wellDT<-rbindlist(lapply(unique(dtb$Well),function(well){
      setkey(dtb,Well)
      dtbw<-dtb[well,]
      #Add predictions from the full grid
      setkey(dtbw,ECMp)
      m <- loess(value~PrintRow+PrintColumn,dtbw["COL1",], span=span)
      dtbw[[paste0("PredictedFGLoess",span,"Value")]] <- predict(m,dtbw)
      return(dtbw)
    }))
  }))
}

addFGRFPredictions<-function(dt){
  rfDT <- rbindlist(lapply(barcodes,function(barcode){
    setkey(dt,Barcode)
    dtb<-dt[barcode,]
    wellDT<-rbindlist(lapply(unique(dtb$Well),function(well){
      setkey(dtb,Well)
      dtbw<-dtb[well,]
      #Add predictions from the full grid
      setkey(dtbw,ECMp)
      m <- randomForest(value~PrintRow+PrintColumn,dtbw["COL1",])
      dtbw$PredictedFGRFValue <- predict(m,dtbw)
      return(dtbw)
    }))
  }))
}

addFGknnPredictions<-function(dt){
  rfDT <- rbindlist(lapply(barcodes,function(barcode){
    setkey(dt,Barcode)
    dtb<-dt[barcode,]
    wellDT<-rbindlist(lapply(unique(dtb$Well),function(well){
      setkey(dtb,Well)
      dtbw<-dtb[well,]
      #Add predictions from the full grid
      as.integer(knn(train=dtbw[,.(PrintRow,PrintColumn)], cl=factor(dtbw[,value])))
      m <- randomForest(value~PrintRow+PrintColumn,dtbw)
      dtbw$PredictedFGRFValue <- predict(m,dtbw)
      return(dtbw)
    }))
  }))
}

#load the LOO modeled data instead of recalculating it
if(!devel){
  load("preds.RData")
} else {
  preds <- merge(merge(merge(addLoessPredictions(gslDT,span=.5), addLoessPredictions(gslDT, span=1)),addRFPredictions(gslDT)),addknnPredictions(gslDT))
  #Add error values for each prediction
  preds <- preds[,PredictedLoessValue_0.5Error:=value-PredictedLoessValue_0.5]
  preds <- preds[,PredictedLoessValue_1Error:=value-PredictedLoessValue_1]
  preds <- preds[,PredictedRFValueError:=value-PredictedRFValue]
  preds <- preds[,PredictedknnValueError:=value-PredictedknnValue]
  save(preds,file="preds.RData")
}
setnames(slDT, "Spot_PA_SpotCellCount","value")
slDT$PrintRow <- slDT$ArrayRow
slDT$PrintColumn <- slDT$ArrayColumn
slDT <- addFGLoessPredictions(slDT,span = 0.5)
slDT <- addFGLoessPredictions(slDT, span = 1)
slDT <- addFGRFPredictions(slDT)


```


```{r SCCPredictedResidualArrays, fig.width=3.7,fig.height=4, eval=TRUE}
setkey(preds,Barcode)
lowThreshValue <- quantile(preds$PredictedLoessValue_0.5,probs=.02,na.rm=TRUE)
highThreshValue <- quantile(preds$PredictedLoessValue_0.5,probs=.98,na.rm=TRUE)

for(barcode in barcodes){
  DT <- preds[barcode,]
  p <- create8WellPseudoImageTriColor(DT, pr = "PredictedLoessValue_0.5",prDisplay = "Predicted Loess Values, span=.5",lowThreshValue = lowThreshValue, highThreshValue = highThreshValue)
  suppressWarnings(print(p))
}

```

```{r, fig.width=3.7,fig.height=4, eval=TRUE}
setkey(preds,Barcode)
lowThreshValue <- quantile(preds$PredictedLoessValue_1,probs=.02,na.rm=TRUE)
highThreshValue <- quantile(preds$PredictedLoessValue_1,probs=.98,na.rm=TRUE)

for(barcode in barcodes){
  DT <- preds[barcode,]
  p <- create8WellPseudoImageTriColor(DT, pr = "PredictedLoessValue_1",prDisplay = "Predicted Loess Values, span=1",lowThreshValue = lowThreshValue, highThreshValue = highThreshValue)
  suppressWarnings(print(p))
}

```


```{r, fig.width=3.7,fig.height=4, eval=TRUE}
setkey(preds,Barcode)
lowThreshValue <- quantile(preds$PredictedRFValue_1,probs=.02,na.rm=TRUE)
highThreshValue <- quantile(preds$PredictedRFValue_1,probs=.98,na.rm=TRUE)

for(barcode in barcodes){
  DT <- preds[barcode,]
  p <- create8WellPseudoImageTriColor(DT, pr = "PredictedRFValue",prDisplay = "Predicted Random Forest Values",lowThreshValue = lowThreshValue, highThreshValue = highThreshValue)
  suppressWarnings(print(p))
}

```


```{r, fig.width=3.7,fig.height=4, eval=TRUE}
setkey(preds,Barcode)
lowThreshValue <- quantile(preds$PredictedknnValue_1,probs=.02,na.rm=TRUE)
highThreshValue <- quantile(preds$PredictedknnValue_1,probs=.98,na.rm=TRUE)

for(barcode in barcodes){
  DT <- preds[barcode,]
  p <- create8WellPseudoImageTriColor(DT, pr = "PredictedknnValue",prDisplay = "Predicted knn Values",lowThreshValue = lowThreshValue, highThreshValue = highThreshValue)
  suppressWarnings(print(p))
}

```

```{r MSECalcs}
#Calculate the MSE of each array for each model
preds <- preds[,ArrayMSELoess0.5 := (1/.N)*sum(PredictedLoessValue_0.5Error^2), by="Barcode,Well"]
preds <- preds[,ArrayMSELoess1 := (1/.N)*sum(PredictedLoessValue_1Error^2), by="Barcode,Well"]
preds <- preds[,ArrayMSERF := (1/.N)*sum(PredictedRFValueError^2), by="Barcode,Well"]
preds <- preds[,ArrayMSEknn := (1/.N)*sum(PredictedknnValueError^2), by="Barcode,Well"]
preds <- preds[,Spot_PA_SpotCellCountGridMean := mean(value, na.rm=TRUE), by="Barcode,Well"]

```

###Model fits using MSE


```{r MSEFigure, fig.height=4, fig.width=4}

predsLong  <- gather(preds,"Model","MSE", ArrayMSELoess0.5, ArrayMSELoess1, ArrayMSERF, ArrayMSEknn, factor_key = TRUE) %>%
  select(Model,MSE, Barcode, Well_Ligand) %>%
  unique()

p <- ggplot(predsLong, aes(x=Model, y=MSE)) +
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(alpha=.5, size=rel(.8))+
  ggtitle("Array MSE Values by Model")+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),
        axis.title.x = element_text(size=rel(1)),
        plot.title = element_text(size = rel(.8)),
        strip.text = element_text(size = rel(.5)),
        legend.text=element_text(size = rel(.4)),
        legend.title=element_text(size = rel(.3)))
p

```

The mean MSE values for each model are:  
* Loess Span 0.5: `r sprintf("%1.0f", mean(filter(predsLong, Model=="ArrayMSELoess0.5")$MSE))`  
* Loess Span 1.0: `r sprintf("%1.0f",mean(filter(predsLong, Model=="ArrayMSELoess1")$MSE))`  
* Random Forest: `r sprintf("%1.0f",mean(filter(predsLong, Model=="ArrayMSERF")$MSE))`  
* 1-nn: `r sprintf("%1.0f",mean(filter(predsLong, Model=="ArrayMSEknn")$MSE))`  


The median MSE values for each model are:  
* Loess Span 0.5: `r sprintf("%1.0f", median(filter(predsLong, Model=="ArrayMSELoess0.5")$MSE))`  
* Loess Span 1.0: `r sprintf("%1.0f",median(filter(predsLong, Model=="ArrayMSELoess1")$MSE))`  
* Random Forest: `r sprintf("%1.0f",median(filter(predsLong, Model=="ArrayMSERF")$MSE))`  
* 1-nn: `r sprintf("%1.0f",median(filter(predsLong, Model=="ArrayMSEknn")$MSE))`  



```{r}
slDT <- merge(slDT,unique(select(preds,Barcode,Well,Spot_PA_SpotCellCountGridMean)),by = c("Barcode","Well"), all=TRUE)
slDT <- slDT[,Spot_PA_SpotCellCountGridRes := value-Spot_PA_SpotCellCountGridMean]

```

###Boxplots of Grid Residuals

Each boxplots contains values from all spots with the named ECM protein.

```{r}
p <- ggplot(slDT, aes(x=factor(ECMp), Spot_PA_SpotCellCountGridRes))+
  geom_boxplot()+
  ggtitle("Spot Cell Count - Grid Mean by ECM Protein")+
  labs(x="ECM Protein", y="Spot Cell Count - Grid Mean")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),
        axis.title.x = element_text(size=rel(1)),
        plot.title = element_text(size = rel(.8)),
        strip.text = element_text(size = rel(.5)),
        legend.text=element_text(size = rel(.4)),
        legend.title=element_text(size = rel(.3)))
p

```


```{r, fig.height=20}
p <- ggplot(slDT, aes(x=factor(ECMp), Spot_PA_SpotCellCountGridRes))+
  geom_boxplot()+
  ggtitle("Spot Cell Count - Grid Mean by ECM Protein")+
  labs(x="ECM Protein", y="Spot Cell Count - Grid Mean")+
  facet_wrap(~Well_Ligand, ncol = 4)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.4)),
        axis.title.x = element_text(size=rel(1)),
        plot.title = element_text(size = rel(.8)),
        strip.text = element_text(size = rel(.5)),
        legend.text=element_text(size = rel(.4)),
        legend.title=element_text(size = rel(.3)))
p

```

###Residuals from Predictions

For the loess and random forest models (based on the COL1 grids), subtract the predicted spot cell count from the actual spot cell count and summarize the residuals by ECM protein. These box plots summarize the ECM protein effects by removing the ligand effects and correct for spatial variations within each array.  

```{r}

p <- ggplot(slDT, aes(x=factor(ECMp), value-PredictedFGLoess0.5Value))+
  geom_boxplot()+
  coord_cartesian(ylim = c(-100,100))+
  ggtitle("Spot Cell Count - Loess(span=0.5) Prediction by ECM Protein")+
  labs(x="ECM Protein", y="Spot Cell Count - Prediction")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),
        axis.title.x = element_text(size=rel(1)),
        plot.title = element_text(size = rel(.8)),
        strip.text = element_text(size = rel(.5)),
        legend.text=element_text(size = rel(.4)),
        legend.title=element_text(size = rel(.3)))
p

p <- ggplot(slDT, aes(x=factor(ECMp), value-PredictedFGLoess1Value))+
  geom_boxplot()+
  coord_cartesian(ylim = c(-100,100))+
  ggtitle("Spot Cell Count - Loess(span=1) Prediction by ECM Protein")+
  labs(x="ECM Protein", y="Spot Cell Count - Prediction")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),
        axis.title.x = element_text(size=rel(1)),
        plot.title = element_text(size = rel(.8)),
        strip.text = element_text(size = rel(.5)),
        legend.text=element_text(size = rel(.4)),
        legend.title=element_text(size = rel(.3)))
p

p <- ggplot(slDT, aes(x=factor(ECMp), value-PredictedFGRFValue))+
  geom_boxplot()+
  coord_cartesian(ylim = c(-100,100))+
  ggtitle("Spot Cell Count - Random Forest Prediction by ECM Protein")+
  labs(x="ECM Protein", y="Spot Cell Count - Prediction")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),
        axis.title.x = element_text(size=rel(1)),
        plot.title = element_text(size = rel(.8)),
        strip.text = element_text(size = rel(.5)),
        legend.text=element_text(size = rel(.4)),
        legend.title=element_text(size = rel(.3)))
p

```

###Observed vs Predicted

Compare the observed spot cell counts to the random forest COl1 grid predictions. The predictions are for the cell count if the spot contained only COL1. The differences between the obeserved values for ECM proteins different from COL1 and the predicted values can be interpreted as the biological signal due to the added ECM proteins.

```{r, fig.height=13}
p <- ggplot(slDT, aes(x=PredictedFGRFValue, y=value))+
  geom_point(alpha=.2, size=.5)+
  coord_cartesian(xlim=c(0,200), ylim = c(0,200))+
  ggtitle("Raw vs Random Forest Predictions Spot Cell Counts by Well")+
  labs(x="Random Forest Predictions", y="Spot Cell Count Observed")+
  facet_grid(Barcode~Well)

p
```

###Observed vs Predicted in the COL1 grid

These figures compare the obeserved vs. predicted values in only the COL1 spots. These show the fit of the loess and random forest models. 

```{r, fig.height=13}
setkey(slDT,ECMp)
dt <- slDT["COL1",]
p <- ggplot(dt, aes(x=PredictedFGLoess0.5Value, y=value))+
  geom_point(alpha=.2, size=.5)+
  geom_abline(intercept = 0,slope = 1)+
  coord_cartesian(xlim=c(0,200), ylim = c(0,200))+
  ggtitle("Raw vs Loess (span=0.5) Predictions Spot Cell Counts by Well")+
  labs(x="Loess Predictions", y="Spot Cell Count Observed")+
  facet_grid(Barcode~Well)

p

```


```{r, fig.height=13}
setkey(slDT,ECMp)
dt <- slDT["COL1",]
p <- ggplot(dt, aes(x=PredictedFGLoess1Value, y=value))+
  geom_point(alpha=.2, size=.5)+
  geom_abline(intercept = 0,slope = 1)+
  coord_cartesian(xlim=c(0,200), ylim = c(0,200))+
  ggtitle("Raw vs Loess (span=1) Predictions Spot Cell Counts by Well")+
  labs(x="Loess Predictions", y="Spot Cell Count Observed")+
  facet_grid(Barcode~Well)

p

```


```{r, fig.height=13}
setkey(slDT,ECMp)
dt <- slDT["COL1",]
p <- ggplot(dt, aes(x=PredictedFGRFValue, y=value))+
  geom_point(alpha=.2, size=.5)+
  geom_abline(intercept = 0,slope = 1)+
  coord_cartesian(xlim=c(0,200), ylim = c(0,200))+
  ggtitle("Raw vs Random Forest Predictions Spot Cell Counts by Well")+
  labs(x="Random Forest Predictions", y="Spot Cell Count Observed")+
  facet_grid(Barcode~Well)

p

```

