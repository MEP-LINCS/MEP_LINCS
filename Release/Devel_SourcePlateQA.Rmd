---
title: "Mep-LINCS MCF10A Source Plate QA"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
---


```{r global_options_Setup, include=FALSE}
#Author: Mark Dane, copyright 2016

knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE)

```

```{r}

library("ggplot2")
library("reshape2")
library("data.table")
library("limma")
library("MEMA")
library("grid")
library("knitr")
library("gplots")
library("RColorBrewer")
library(plotly)
library(DT)

x <- data.table(CellLine=rep(c("MCF10A"),each=1),
                StainingSet = rep(c("SS20")),
                Signal=rep(c("SCC"), each=1),
                Method=c("RUV3Loess"),
                inputFileName=rep(c("../AnnotatedData/MCF10A_SS0_none_v2_av1.6_SpotLevel.txt"), each=1))
```

```{r , include=FALSE}

#source("MEPLINCSFunctions.R")

#Read in file based on name in dataframe
l3 <- fread(x[["inputFileName"]], showProgress = FALSE)
#Cleanup ECMp names in gal file 
l3$ECMp <- sub("_{1}[[:alpha:]]*","",l3$ECMp)
l3$ECMp <- sub("_{1}[[:alnum:]]*","",l3$ECMp)

 l3$OmeroDetailURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/img_detail/',l3$ImageID,'/"',' target="_blank">Omero</a>')
  l3$OmeroThumbnailURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/render_thumbnail/',l3$ImageID,'/"',' target="_blank">Omero</a>')
  l3$OmeroImageURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/render_image/',l3$ImageID,'/"',' target="_blank">Omero</a>')

```


```{r simulatePoorPin, eval=FALSE}

l1$Spot_PA_SpotCellCount[l1$Block==6] <-as.integer( l1$Spot_PA_SpotCellCount[l1$Block==6]*.25+1)

```

```{r simulateEmptyingWell, eval=FALSE}
l1 <- setkey(l1,Barcode,Well,Spot)
l1$Spot_PA_SpotCellCount[l1$Block==5 & l1$Row==1 & l1$Column==1] <-as.integer( l1$Spot_PA_SpotCellCount[l1$Block==5 & l1$Row==1 & l1$Column==1]*seq(1,0,length.out=length(l1$Spot_PA_SpotCellCount[l1$Block==5 & l1$Row==1 & l1$Column==1])))

```

```{r}
#Keep the control wells separate
l3$Ligand[grepl("FBS",l3$Ligand)] <- paste(l3$Ligand[grepl("FBS",l3$Ligand)],"P",as.numeric(factor(l3$Barcode[grepl("FBS",l3$Ligand)])),sep="")
l3$MEP <- paste(l3$ECMp,l3$Ligand,sep="_")

#Delete the fiducial and blank spots
setkey(l3, "ECMp")
l3 <- l3[!grepl("fiducial|Fiducial|blank|PBS",l3$ECMp)]
#Add spatial residuals
l3 <- l3[, SCCRel := calcResidual(Spot_PA_SpotCellCount), by="MEP"]

```

```{r createMatrices}
#For an array  Unit of study there are 64 'samples'of 694 spots with 8 replicates
#Create a spot assignment that recognizes rotated B row arrays
l3$RSpot <- l3$Spot
l3$RSpot[grepl("B",l3$Well)] <- 701-l3$RSpot[grepl("B",l3$Well)]
#Add in ligand and ECMp names so they will carry through the normalization
l3$BWL <- paste(l3$Barcode,l3$Well,l3$Ligand,sep="_")
l3$SE <- paste(l3$RSpot,l3$ECMp,sep="_")
l3$ES <- paste(l3$ECMp,l3$RSpot,sep="_")
l3$ESB <- paste(l3$ECMp,l3$RSpot,l3$Block, sep="_")
l3$BW <- paste(l3$Barcode,l3$Well,sep="_")
l3$WSE <- paste(l3$Well, l3$RSpot,l3$ECMp,sep="_")

#Cast to get mel values by barcode_well_ligand rows and spot columns
#Coerce missing values to have near 0 values
if(x[["Signal"]] %in% c("EdU", "DNA2N", "Ecc","Spot")){
  fill <- log2(.01/(1-.01))
} else if(unique(x[["Signal"]]) %in% c("LineageRatioLog2", "SCC")){
  fill <- 0
} else(stop(paste("Need fill value for",unique(x[["Signal"]])," signal"))) 

```

```{r addResiduals}

l3RelcA <- data.table(dcast(l3, BWL~ES, value.var=paste0(x[["Signal"]],"Rel"), fill = fill))
#Remove the BWL column and use it as rownames in the matrix
l3Relm <- l3RelcA[,grep("BWL",colnames(l3RelcA), value=TRUE, invert=TRUE), with=FALSE]
#Y is a numeric matrix of the raw transformed responses 
#of each spot extracted from the l3 dataset
YRelArray <- matrix(unlist(l3Relm), nrow=nrow(l3Relm), dimnames=list(l3RelcA$BWL, colnames(l3Relm)))
```

### Raw Spot Cell Count Pseudoimages show the baseline data used in the analysis.  

```{r}

p <- ggplot(l3, aes(x=ArrayColumn, y=ArrayRow, fill= Spot_PA_SpotCellCount))+
  geom_tile()+
  scale_fill_gradient(low="white",high="red",oob = scales::squish)+
  ggtitle("Spot Cell Count for Qual Wells")+
  xlab("")+ylab("")+
  guides(fill=FALSE)+
  xlim(.5,20.5)+ylim(35.5,.5)+
  facet_wrap(~Barcode, nrow = 1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.6)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.7)),panel.grid.major = element_line(linetype = 'blank'),panel.background = element_rect(fill = "lightgrey"))
suppressWarnings(print(p))

```

*** 

These arrays are from a time series of four plates printed from the same set of ECM source plates. The images are colored by the raw spot cell count. The analysis of these arrays is to look for ECM source plate or pin issues that are occuring over a print run.  

### Residual Spot Cell Count Pseudoimages show the spot cell count residuals after removing some of the biological signal.  

```{r}
p <- ggplot(l3, aes(x=ArrayColumn, y=ArrayRow, fill= SCCRel))+
  geom_tile()+
  scale_fill_gradient(low="white",high="red",oob = scales::squish)+
  ggtitle("Spot Cell Count Residuals for Qual Wells")+
  xlab("")+ylab("")+
  guides(fill=FALSE)+
  xlim(.5,20.5)+ylim(35.5,.5)+
  facet_wrap(~Barcode, nrow = 1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.6)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.7)),panel.grid.major = element_line(linetype = 'blank'),panel.background = element_rect(fill = "lightgrey"))
suppressWarnings(print(p))

```

*** 

Residual Spot Cell Count  
The residuals are calculated by subtracting the median value of the ECM protein replicates within a well from each of the replicate values. This removes the biological signal associated with the spotted ECM proteins to emphasize the technical variations in the signal such as the position in the array, pin effects and ECM source plate effects.  

### SVD Applied to Array Level

```{r, fig.width=4}

s <- svd(YRelArray)
vDT <- data.table(Value=s$v[,which.max(s$d)], Spot = as.integer(sub(".*_", "",colnames(l3Relm))))
vDT$ArrayRow <- as.integer(ceiling(vDT$Spot/20))
vDT$ArrayColumn <- as.integer((vDT$Spot-1) %% 20 +1)

p <- ggplot(vDT, aes(x=ArrayColumn, y=ArrayRow, fill= Value))+
  geom_tile()+
  scale_fill_gradient(low="white",high="red",oob = scales::squish)+
  ggtitle("Maximum Singular Value Eigenvector\n from Spot Cell Count Residuals")+
  xlab("")+ylab("")+
  guides(fill=FALSE)+
  xlim(20.5,.5)+ylim(.5,35.5)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.6)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.7)),panel.grid.major = element_line(linetype = 'blank'),panel.background = element_rect(fill = "lightgrey"))
suppressWarnings(print(p))

```

***

The plot developed from the Singular Value Decomposition (SVD) analysis of the residuals emphasizes the technical signal in the data. When applied to the spot cell count values across multiple arrays, the plots show areas of variance. For instance, the upper rows in the array have high variance in the SVD as can be seen by comparing the arrays in the raw and residual images. 

SVD is applied to the residuals at the array level as follows.  
* Create residuals by subtracting the median value of the replicates from each replicate value  
* Create an M matrix of residuals that is `r nrow(YRelArray)` rows by `r ncol(YRelArray)` columns. Each row holds residuals for each spot in a MEMA.  
* Apply SVD to the M matrix to get u, d and v matrices.  
* Plot the eignvector in the column of the v matrix which corresponds to the largest singular value in the d matrix. Plot as heat map of 35 rows and 20 columns.  Missing tiles in the heat map correspond to fiducials and blank spots.    

 




```{r}

#Cast to get mel values with Barcode rows and well+Spot+ECMp columns
#Use the names to hold the spot contents
#Coerce missing values to have near 0 proliferation signals
l3RelcB <- data.table(dcast(l3, Barcode~WSE, value.var=paste0(x[["Signal"]],"Rel"),fill = fill))
#Remove the Barcode column and use it as rownames in the matrix
l3Relm <- l3RelcB[,grep("Barcode",colnames(l3RelcB), value=TRUE, invert=TRUE), with=FALSE]
YRelPlate <- matrix(unlist(l3Relm), nrow=nrow(l3Relm), dimnames=list(l3RelcB$Barcode, colnames(l3Relm)))

s <- svd(YRelPlate)
splits <- strsplit2(colnames(l3Relm), split="_")
vDT <- data.table(Value=-s$v[,which.max(s$d)], Well=splits[,1], Spot=as.integer(splits[,2]))
vDT$ArrayRow <- as.integer(ceiling(vDT$Spot/20))
vDT$ArrayColumn <- as.integer((vDT$Spot-1) %% 20 +1)
```


### Analysis of Spot Level Signals over Time includes details when hovering over a line.


```{r SpotTimeCourse}

l3cTC <- data.table(dcast(l3, BWL~ESB, value.var="Spot_PA_SpotCellCount", fill = fill))
#Remove the BWL column and use it as rownames in the matrix
l3m <- l3cTC[,grep("BWL",colnames(l3cTC), value=TRUE, invert=TRUE), with=FALSE]
#Y is a numeric matrix of the raw transformed responses 
#of each spot extracted from the l3 dataset
YArray <- matrix(unlist(l3m), nrow=nrow(l3m), dimnames=list(l3cTC$BWL, colnames(l3m)))

setkey(l3cTC, BWL)
l3cTC$PrintOrder <- 1:nrow(l3cTC)
l3melt <- melt(l3cTC, id.vars=c("BWL","PrintOrder"), measure=patterns("_"),variable.name = "ESB", value.name = "Spot_PA_SpotCellCount")
splits <- strsplit2(l3melt$ESB,split="_")
l3melt$Block <- strsplit2(l3melt$ESB,split="_")[,3]

p <- ggplot(l3melt, aes(x=PrintOrder, y=Spot_PA_SpotCellCount, colour=ESB))+
  geom_smooth(size=.1, se = FALSE)+
  guides(colour=FALSE)+
  ggtitle("Spot Level Signals over Time")
#print(p)
ggplotly(p)

```

***

This plot indicates when a well in a source plate is running low of reagent. While the well has reagents, the Spot Cell Count value should be fairly horizontal. When a well runs dry, fewer cells will grow on the spots made from that well and the track for that well will drop down and remain low.


### Analysis of Spot Level Residuals over Time includes details when hovering over a line.


```{r SpotResidualTimeCourse}

l3RelcTC <- data.table(dcast(l3, BWL~ESB, value.var=paste0(x[["Signal"]],"Rel"), fill = fill))
#Remove the BWL column and use it as rownames in the matrix
l3Relm <- l3RelcTC[,grep("BWL",colnames(l3RelcTC), value=TRUE, invert=TRUE), with=FALSE]
#Y is a numeric matrix of the raw transformed responses 
#of each spot extracted from the l3 dataset
YRelArray <- matrix(unlist(l3Relm), nrow=nrow(l3Relm), dimnames=list(l3RelcTC$BWL, colnames(l3Relm)))

setkey(l3RelcTC, BWL)
l3RelcTC$PrintOrder <- 1:nrow(l3RelcTC)
l3Relmelt <- melt(l3RelcTC, id.vars=c("BWL","PrintOrder"), measure=patterns("_"),variable.name = "ESB", value.name = paste0(x[["Signal"]],"Rel"))
splits <- strsplit2(l3Relmelt$ESB,split="_")
l3Relmelt$Block <- strsplit2(l3Relmelt$ESB,split="_")[,3]

p <- ggplot(l3Relmelt, aes(x=PrintOrder, y=SCCRel, colour=ESB))+
  geom_smooth(size=.1, se = FALSE)+
  guides(colour=FALSE)+
  ggtitle("Spot Level Residuals over Time")
#print(p)
ggplotly(p)

```

***

This plot indicates when a well in a source plate is running low of reagent. While the well has reagents, the residual of the Spot Cell Count value should be near 0. When a well runs dry, fewer cells will grow on the spots made from that well and the track for that well will drop down from 0 and remain low.

The Spot Level Signals over Time uses the residuals at the spot level as follows.  
* Create residuals by subtracting the median value of the replicates from each spot value.  
* Create an M matrix of residuals that is `r nrow(YRelArray)` rows by `r ncol(YRelArray)` columns. Each column holds residuals for one spot in all MEMAs.  
* Plot a time course for each spot  


### Pin Spot Cell Count Over Time includes details when hovering over a line.

```{r}

p <- ggplot(l3melt, aes(x=PrintOrder, y=Spot_PA_SpotCellCount, colour=Block))+
  geom_smooth(size=.1, se = FALSE)+
  guides(colour=FALSE)+
  ggtitle("Pin Summarized Spot Level Signals over Time")
#print(p)
ggplotly(p)

```

***

The arrays are printed by twenty-eight pins arranged in a four by seven print head. Each pin creates a print block with five rows and five columns. This plot shows the spot cell count for each pin. Pins with lower spot cell counts indicate either issues with the pin or uneven cell seeding/growth in regions of the array.  

The Pin Summarized Spot Level Signals over Time is calculated as follows:  
* Median summarize all spot residuals for each pin  
* Plot a time course of the spot cell count residuals for each pin  

### Pin Spot Cell Count Residuals Over Time includes details when hovering over a line.

```{r}

p <- ggplot(l3Relmelt, aes(x=PrintOrder, y=SCCRel, colour=Block))+
  geom_smooth(size=.1, se = FALSE)+
  guides(colour=FALSE)+
  ggtitle("Pin Summarized Spot Level Residuals over Time")
#print(p)
ggplotly(p)

```

***

The arrays are printed by twenty-eight pins arranged in a four by seven print head. Each pin creates a print block with five rows and five columns. This plot shows the residual spot cell count for each pin. Pins with residuals different from zero indicate either issues with the pin or uneven cell seeding/growth in regions of the array.  

The Pin Summarized Spot Level Signals over Time uses the residuals at the spot level as follows:  
* Create residuals by subtracting the median value of the replicates from each spot value.  
* Create an M matrix of residuals that is `r nrow(YRelArray)` rows by `r ncol(YRelArray)` columns. Each column holds residuals for one spot in all MEMAs.  
* Median summarize all spot residuals for each pin  
* Plot a time course of the spot cell count residuals for each pin  

### SpotCellCount Datatable shows the raw and residual data. This table can be searched by keyword and sorted by any column. 

```{r SCCDatatable}
colNames <- c("ECMp","Barcode", "ArrayRow", "ArrayColumn", "Block", "Spot_PA_SpotCellCount","SCCRel")
colNamesDisplay <- c("ECMp","Barcode","Row","Column", "Block", "Spot Cell Count", "Spot Cell Count Residual")

datatable(format(l3[, colNames, with=FALSE], digits=3, scientific = FALSE, nsmall=0), options = list(pageLength = 5), colnames = colNamesDisplay)

```
