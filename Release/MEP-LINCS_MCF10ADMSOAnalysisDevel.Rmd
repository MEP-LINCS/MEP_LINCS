---
title: MEP-LINCS MCF10A DMSO Analysis
author: Mark Dane
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    source_code: embed
    runtime: shiny
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)

```

```{r global, include=FALSE}
# load data in 'global' chunk so it can be shared by all users of the dashboard
library(ggplot2)

```

```{r functions}
#Author: Mark Dane, copyright 2016
#Stored and run from MEP-LINCS/MEP_LINCS/Release

source("MEPLINCSFunctions.R")
source("MEP-LINCS QANorm Functions.R")

createPCAModel <- function(dt,fvNames){
  #delete any non-varying signals that cannot be scaled to unit variance
  stdDevs <- apply(dt[,fvNames, with=FALSE], 2, sd)
  if(any(stdDevs==0))  cat(paste("Deleting",fvNames[stdDevs==0], "due to 0 variance\n"))
  fvNames <- fvNames[!stdDevs==0]
  PCAModel <- prcomp(as.formula(paste(" ~ ", paste(fvNames, collapse = "+"))), data = dt, scale.= TRUE)
  rownames(PCAModel$x)<-paste(dt$MEP,gsub("LI8X00","",dt$Barcode), sep="_")
  return(PCAModel)
}

plotPCs <- function(m, PCs, colour, title, legendTitle, xlim=NULL, ylim=NULL, colorByCtrls=TRUE, highlightName=NULL){
  if(!(length(PCs)==3&class(m)=="prcomp")) stop("PCs must have a length of 3 and m must be of class prcomp")
  
  if(is.null(highlightName)){
    p12 <- ggplot(data.frame(m$x), aes_string(x = PCs[1], y = PCs[2], colour = colour)) +
      geom_point(size = rel(.5), alpha = .5) +
      labs(colour = legendTitle)+
      ggtitle(title)+
      guides(colour=FALSE)+
      coord_cartesian(xlim=xlim, ylim=ylim)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
    
    p23 <- ggplot(data.frame(m$x), aes_string(x = PCs[2], y = PCs[3], colour = colour)) +
      geom_point(size = rel(.5), alpha = .5) +
      labs(colour = legendTitle)+
      ggtitle(title)+
      guides(colour=FALSE)+
      coord_cartesian(xlim=xlim, ylim=ylim)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
    
    p13 <- ggplot(data.frame(m$x), aes_string(x = PCs[1], y = PCs[3], colour = colour)) +
      geom_point(size = rel(.5), alpha = .5) +
      labs(colour = legendTitle)+
      ggtitle(title)+
      guides(colour=FALSE)+
      coord_cartesian(xlim=xlim, ylim=ylim)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
    
  } else {
    #Dim out all MEPs except the selected
    dimColour<-"cornflowerblue"
    p12 <- ggplot(data.frame(m$x), aes_string(x = PCs[1], y = PCs[2])) +
      geom_point(size = rel(.5), alpha = .5, colour = dimColour) +
      labs(colour = legendTitle)+
      ggtitle(paste(title, "with",highlightName, "highlighted"))+
      guides(colour=FALSE)+
      coord_cartesian(xlim=xlim, ylim=ylim)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
    
    p23 <- ggplot(data.frame(m$x), aes_string(x = PCs[2], y = PCs[3])) +
      geom_point(size = rel(.5), alpha = .5, colour = dimColour) +
      labs(colour = legendTitle)+
      ggtitle(paste(title, "with",highlightName, "highlighted"))+
      guides(colour=FALSE)+
      coord_cartesian(xlim=xlim, ylim=ylim)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
    
    p13 <- ggplot(data.frame(m$x), aes_string(x = PCs[1], y = PCs[3])) +
      geom_point(size = rel(.5), alpha = .5, colour = dimColour) +
      labs(colour = legendTitle)+
      ggtitle(paste(title, "with",highlightName, "highlighted"))+
      guides(colour=FALSE)+
      coord_cartesian(xlim=xlim, ylim=ylim)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
  }
  
  if(colorByCtrls){
    p12 <- p12 + geom_point(data=data.frame(m$x[grepl("FBS",rownames(m$x)),]),colour="black",size = rel(.5), alpha = .4)
    p12 <- p12 + geom_point(data=data.frame(m$x[grepl("NID1",rownames(m$x)),]),colour="chocolate",size = rel(.5), alpha = .4)
    p23 <- p23 + geom_point(data=data.frame(m$x[grepl("FBS",rownames(m$x)),]),colour="black",size = rel(.5), alpha = .4)
    p23 <- p23 + geom_point(data=data.frame(m$x[grepl("NID1",rownames(m$x)),]),colour="chocolate",size = rel(.5), alpha = .4)
    p13 <- p13 + geom_point(data=data.frame(m$x[grepl("FBS",rownames(m$x)),]),colour="black",size = rel(.5), alpha = .4)
    p13 <- p13 + geom_point(data=data.frame(m$x[grepl("NID1",rownames(m$x)),]),colour="chocolate",size = rel(.5), alpha = .4)
  }
  
  if(!is.null(highlightName)){
    p12 <- p12 + geom_point(data=data.frame(m$x[grepl(highlightName,rownames(m$x)),]),colour="gold",size = rel(.5), alpha = .8)
    p23 <- p23 + geom_point(data=data.frame(m$x[grepl(highlightName,rownames(m$x)),]),colour="gold",size = rel(.5), alpha = .8)
    p13 <- p13 + geom_point(data=data.frame(m$x[grepl(highlightName,rownames(m$x)),]),colour="gold",size = rel(.5), alpha = .8)
  }
  
  print(p12)
  print(p23)
  print(p13)
  
}

plotScree <- function(m,nrPCs=9,main  = paste("PCA Scree Plot for",cellLine,ss)){
  var <- m$sd[1:nrPCs]^2
  var.percent <- var/sum(var) * 100
  barplot(var.percent, xlab="PC", ylab="Percent Variance", names.arg=1:length(var.percent), las=1, ylim=c(0,max(var.percent)), col="gray", main=main)
}

shortenHA <- function(x){
  x$ECMp <- gsub("hyaluronicacid","HA",x$ECMp)
  x$ECMp <- gsub("lessthan","<",x$ECMp)
  x$ECMp <- gsub("greaterthan",">",x$ECMp)
  x$MEP <- paste(x$ECMp,x$Ligand,sep = "_")
  return(x)
}
#Add an index for the plate in the ligand set
addLigandPlate <- function(dt){
  
}
addOmeroIDs <- function(dt){
  if(any(grepl("^ImageID$",colnames(dt)))){
    dt <- dt[,OmeroDetailURL := paste0('<a href="https://meplincs.ohsu.edu/webclient/img_detail/',ImageID,'/"',' target="_blank">Omero</a>')]
    dt <- dt[,OmeroThumbnailURL := paste0('<a href="https://meplincs.ohsu.edu/webclient/render_thumbnail/',ImageID,'/"',' target="_blank">Omero</a>')]
    dt <- dt[,OmeroImageURL := paste0('<a href="https://meplincs.ohsu.edu/webclient/render_image/',ImageID,'/"',' target="_blank">Omero</a>')]
  }
  return(dt)
}

create8WellPseudoImage <- function(DT, pr, prDisplay,highThresh = .99, lowThresh = .01, highThreshValue=NULL, lowThreshValue=NULL){
  #find high and low values
  if(is.null(highThreshValue)) highThreshValue<-quantile(DT[[pr]],probs = highThresh,na.rm=TRUE)
  if(is.null(lowThreshValue)) lowThreshValue<-quantile(DT[[pr]],probs = lowThresh,na.rm=TRUE)
  p <- ggplot(DT, aes_string(x="ArrayColumn", y="ArrayRow",colour=pr))+
    geom_point(size=rel(.25))+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red", limits=c(lowThreshValue, highThreshValue), oob=squish)+
    guides(colour = guide_legend(prDisplay, keywidth = .5, keyheight = .5))+
    ggtitle(paste("\n\n",prDisplay,"for",unique(DT$CellLine), "cells \nin plate",unique(DT$Barcode)))+
    xlab("")+ylab("")+
    theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.8)),
          axis.title.x = element_text(size=rel(.5)),
          plot.title = element_text(size = rel(.8)),
          strip.text = element_text(size = rel(.5)),
          legend.text=element_text(size = rel(.4)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well_Ligand, ncol=4)
}
medianSummarizel4 <- function(dt){
  #median summarize the MEP replicates in a datatable
  #Select all signal names and the minimal metadata
  dtNames <- grep("^Ligand$|^ECMp$|MEP|^Well$|_CP_|_PA_",x = names(dt), value = TRUE)
  
  #Create a datatable of the signals and minimal metadata
  dtKeep <- dt[, dtNames, with = FALSE]
  dtMedians <- dtKeep[, lapply(.SD, numericMedian), keyby = "Ligand,ECMp,MEP,Well"]
  return(dtMedians)
}

meanSummarizel4 <- function(dt){
  #median summarize the MEP replicates in a datatable
  #Select all signal names and the minimal metadata
  dtNames <- grep("^Ligand$|^ECMp$|MEP|^Well$|_CP_|_PA_",x = names(dt), value = TRUE)
  
  #Create a datatable of the signals and minimal metadata
  dtKeep <- dt[, dtNames, with = FALSE]
  dtMeans <- dtKeep[, lapply(.SD, numericMean), keyby = "Ligand,ECMp,MEP,Well"]
  return(dtMeans)
}

meanSummarizel3 <- function(dt){
  #median summarize the Spot replicates in a datatable
  #Select all signal names and the minimal metadata
  dtNames <- grep("^Ligand$|^ECMp$|MEP|^Well$|PrintSpot|_CP_|_PA_",x = names(dt), value = TRUE)
  
  #Create a datatable of the signals and minimal metadata
  dtKeep <- dt[, dtNames, with = FALSE]
  dtMeans <- dtKeep[, lapply(.SD, numericMean), keyby = "Ligand,ECMp,MEP,Well,PrintSpot"]
  return(dtMeans)
}

numericMean <- function(x){
  as.numeric(mean(x, na.rm=TRUE))
}

btLogit <- function(x){
  2^x/(1+2^x)
}
```



```{r setup}

library("ggplot2")
library(scales)
library("data.table")
library("MEMA")
library("grid")
library("knitr")
library("gplots")
library("RColorBrewer")
library(DT)
library(d3heatmap)
library(plotly)
#library(corrplot)
library(RUVnormalize)
library(ruv)
library(Rtsne)
library(XLConnect)
library(readxl)

#Items to be generalized
datasetName <- "MCF10ADMSO"
cellLine <- "MCF10A"

#Setup colors for Barcode and text in all heatmaps
selDark2 <- colorRampPalette(brewer.pal(8,"Dark2"))
plateCol <- selDark2(8)
hmcols<-colorRampPalette(c("blue","white","red"))(16)


#Read in the data.table that holds every spot in the cell line
#and can be used to index to the images
l3C <- fread(unique(paste0("../AnnotatedData/",datasetName, "_SSF","_Level3.txt")), showProgress = FALSE)
#Add backtransformed values for some logit transformed signals
l3C <- l3C[,Nuclei_PA_Cycle_DNA2NProportionLogitRUVLoessBacktransformed:= btLogit(Nuclei_PA_Cycle_DNA2NProportionLogitRUVLoess)]
l3C <- l3C[,Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoessBacktransformed:= btLogit(Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoess)]
l3C <- addOmeroIDs(l3C)
#Read in the MEP-Level datasset for the cell line
l4C <- fread(unique(paste0("../AnnotatedData/",datasetName, "_SSF","_Level4.txt")), showProgress = FALSE)

#Add backtransformed values for some logit transformed signals
l4C <- l4C[,Nuclei_PA_Cycle_DNA2NProportionLogitRUVLoessBacktransformed:= btLogit(Nuclei_PA_Cycle_DNA2NProportionLogitRUVLoess)]
l4C <- l4C[,Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoessBacktransformed:= btLogit(Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoess)]


#Read in curated signals with descriptions
level4Signals <- read_excel("/graylab/share/dane/MEP-LINCS/MEP_LINCS/FeatureDescriptionsLevel4.xls")

```



###Introduction
This analysis is of the MEP-LINCS `r cellLine`  MEMA experiments performed in eight well plates. The data is collected at the cell level from images captured on an automated Nikon microscope. The cell level data is summarized for each MEMA spot, RUV and loess normalized, then replicate spots are summarized to the MEP level.  

The MEP-level dataset is stored and manipulated as a matrix where each of the `r dim(l4C)[1]` rows are a unique MEP and each of the `r dim(l4C)[2]` columns are signals or metadata.

The Spot-level dataset is a matrix where each of the `r dim(l3C)[1]` rows is a spot and each of the `r dim(l3C)[2]` columns are signals or metadata. The spot level data is a sparse matrix where the each row has values from one staining set and NA values for the other.


###Proliferation Boxplots


```{r EdUBoxplotsFull, fig.width=12, fig.height=5}

dt <- l4C[!grepl("NID1|ELN",l4C$ECMp),]
dt$gsColours <- "Samples"
dt$gsColours[grepl("BMP",dt$Ligand)] <- "Selected"
dt$gsColours[grepl("FBS",dt$Ligand)] <- "NegCtrl"
dt$gsColours <- factor(dt$gsColours,levels=c("Samples","Selected","NegCtrl"),ordered=TRUE)
textOrdered <- levels(reorder(dt$Ligand, dt$Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoess, FUN=median))
textColourVec <- rep("black",length.out=length(textOrdered))
textColourVec[grepl("BMP",textOrdered)] <- "gold"
textColourVec[grepl("FBS",textOrdered)] <- "blue"

p <- ggplot(dt, aes(x=reorder(Ligand, Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoessBacktransformed, FUN=median), y=Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoessBacktransformed, fill=gsColours))+
  geom_boxplot(outlier.colour = NA, alpha=.5)+
  scale_fill_manual(values = c("transparent", "gold", "blue",muted("red")))+
  guides(fill=FALSE, colour=FALSE)+
  #coord_cartesian(ylim = c(-6,-1.5))+
  xlab("Ligand")+ylab("Normalized EdU+")+
  ggtitle("MEP EdU+ Response by Ligand")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.7), colour=textColourVec), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(1)),legend.title=element_text(size = rel(1)))

p <- p +  geom_jitter(aes(colour=ECMp),size=rel(.3),alpha=.5)
print(p)


```

***
These box plots show the RUV and loess normalized MEP level data for the gated EdU+ proliferation signal stratified by the ligands. The BMP values are highlighted as these are part of the validation datasets. The NID1 and ELN data are filtered due to low cell counts that create extreme values.  

###Proliferation Boxplots by ECMp Protein


```{r EdUBoxplotsECMp, fig.width=12, fig.height=5}

dt <- l4C

p <- ggplot(dt, aes(x=reorder(ECMp, Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoessBacktransformed, FUN=median), y=Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoessBacktransformed))+
  geom_boxplot(outlier.colour = NA, alpha=.5, fill="transparent")+
  guides(fill=FALSE, colour=FALSE)+
  xlab("ECM Protein")+ylab("Normalized EdU+")+
  ggtitle("MEP EdU+ Response by ECM Protein")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.7)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(1)),legend.title=element_text(size = rel(1)))

p <- p +  geom_jitter(aes(colour=Ligand),size=rel(.3),alpha=.5)
print(p)


```

***
These box plots show the RUV and loess normalized MEP level data for the gated EdU+ proliferation signal stratified by the ECM protein.

###Explore Selected Signals


```{r}
#find the curated signals and their values that are in this dataset
dt <- l4C[,level4Signals$Binding[level4Signals$Binding %in% colnames(l4C)], with=FALSE]
#Reduce the level4 signals to those that are available
dtSignals <- level4Signals[level4Signals$Binding %in% colnames(l4C),]
#dt <- setnames(dt,colnames(dt),level4Signals$Name[level4Signals$Binding %in% colnames(dt)])

fillRow(height = "100%", flex = c(NA, 1), 
        verticalLayout(
          selectInput("xaxis", "X Axis:", choices = dtSignals$Name, selected="Spot Cell Count"),
          selectInput("yaxis", "Y Axis:", choices = dtSignals$Name, "EdU+ Proportion (normalized)"),
          selectInput("colour", "Colour by:", choices = dtSignals$Name, "Ligand"),
          numericInput("SCCThreshold","Spot Cell Count Threshold",value = 0),
          plotOutput("scatterPlot", height = "100%")),
        
        output$scatterPlot <- renderPlotly({
          dt <- dt[dt$Spot_PA_SpotCellCount>=input$SCCThreshold,]
          xaxisBinding <- dtSignals$Binding[dtSignals$Name==input$xaxis]
          yaxisBinding <- dtSignals$Binding[dtSignals$Name==input$yaxis]
          colourBinding <- dtSignals$Binding[dtSignals$Name==input$colour]
          
          p <- ggplot(dt, aes_string(x=xaxisBinding, y= yaxisBinding, colour=colourBinding))+
            geom_point()+
            stat_smooth(span = 1,se = FALSE)+
            labs(x=input$xaxis, y=input$yaxis)
          ggplotly(p)
        })
)
```

***
x axis: 
`r renderText({dtSignals$Description[dtSignals$Name==input$xaxis]})`

y axis: 
`r renderText({dtSignals$Description[dtSignals$Name==input$yaxis]})`


