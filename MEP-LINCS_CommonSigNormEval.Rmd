
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE)

```


```{r functions}
#Author: Mark Dane, copyright 2015

source("~/Documents/MEP-LINCS/MEPLINCSFunctions.R")

createl4KeepRaw <- function (l3) 
{
  #Select all signal names and the minimal metadata
  l4Names <- grep("^Ligand|^ECMp|Barcode|MEP|^Well$|_CP_|_PA_",x = names(l3), value = TRUE)
  l4Names <- grep("_SE", l4Names, value = TRUE, invert = TRUE)
  l4Keep <- l3[, l4Names, with = FALSE]
  l4DT <- l4Keep[, lapply(.SD, numericMedian), keyby = "Ligand,ECMp,MEP,Barcode,Well"]
  return(l4DT)
}

createPCAModel <- function(dt,fvNames){
  #delete any non-varying signals that cannot be scaled to unit variance
  stdDevs <- apply(dt[,fvNames, with=FALSE], 2, sd)
  if(any(stdDevs==0))  cat(paste("Deleting",fvNames[stdDevs==0], "due to 0 variance\n"))
  fvNames <- fvNames[!stdDevs==0]
  PCAModel <- prcomp(as.formula(paste(" ~ ", paste(fvNames, collapse = "+"))), data = dt, scale= TRUE)
}

plotPCs <- function(m, PCs, colour, title, legendTitle){
  if(!(length(PCs)==3&class(m)=="prcomp")) stop("PCs must have a length of 3 and m must be of class prcomp")
  p <- ggplot(data.frame(m$x), aes_string(x = PCs[1], y = PCs[2], colour = colour)) +
    geom_point(size = rel(.5), alpha = .5) +
    labs(colour = legendTitle)+
    ggtitle(title)+
    theme(legend.text=element_text(size = 6),
          plot.title=element_text(size = rel(.7)))+
    guides(colour = guide_legend(override.aes = list(size=6)))
  print(p)
  
  p <- ggplot(data.frame(m$x), aes_string(x = PCs[2], y = PCs[3], colour = colour)) +
    geom_point(size = rel(.5), alpha = .5) +
    labs(colour = legendTitle)+
    ggtitle(title)+
    theme(legend.text=element_text(size = 6),
          plot.title=element_text(size = rel(.7)))+
    guides(colour = guide_legend(override.aes = list(size=6)))
  print(p)
  
  p <- ggplot(data.frame(m$x), aes_string(x = PCs[1], y = PCs[3], colour = colour)) +
    geom_point(size = rel(.5), alpha = .5) +
    labs(colour = legendTitle)+
    ggtitle(title)+
    theme(legend.text=element_text(size = 6),
          plot.title=element_text(size = rel(.7)))+
    guides(colour = guide_legend(override.aes = list(size=6)))
  print(p)
  
}

plotScree <- function(m,nrPCs=9,main  = paste("PCA Scree Plot for",cellLine,ss)){
  var <- m$sd[1:nrPCs]^2
  var.percent <- var/sum(var) * 100
  barplot(var.percent, xlab="PC", ylab="Percent Variance", names.arg=1:length(var.percent), las=1, ylim=c(0,max(var.percent)), col="gray", main=main)
}

```


```{r setup,cache=FALSE}
library("ggplot2")
library("data.table")
library("MEMA")
library("grid")
library("knitr")
library("gplots")
library("RColorBrewer")
library(DT)
library(d3heatmap)
library(plotly)
library(corrplot)

#Setup colors for Barcode and text in all heatmaps
selDark2 <- colorRampPalette(brewer.pal(8,"Dark2"))
plateCol = selDark2(8)
hmcols<-colorRampPalette(c("blue","white","red"))(16)
#Read in the 3 level 3 datasets
l3List <- apply(x, 1, function(fn){
  fread(paste0("./",fn[["cellLine"]],"/",fn[["ss"]],"/AnnotatedData/",fn[["cellLine"]], "_",fn[["ss"]],"_",fn[["rawDataVersion"]],"_",fn[["analysisVersion"]],"_Level3.txt"), showProgress = FALSE)
})

#identify the common signals
commonSignals <- intersect(intersect(colnames(l3List[[1]]),colnames(l3List[[2]])),colnames(l3List[[3]]))

#Combine the common signals into a datatable
l3c <- rbind(l3List[[1]][,commonSignals,with=FALSE],
             l3List[[2]][,commonSignals,with=FALSE],
             l3List[[3]][,commonSignals,with=FALSE])

#Remove normalized and spot level signals
l3c <- l3c[,grep("RUV3|_SE|Spot_PA_Perimeter|Spot_PA_ReplicateCount|BWL|SERC|^k$|NormMethod|SignalType",colnames(l3c),invert=TRUE, value=TRUE), with=FALSE]

#Remove blank spot data
l3c <- l3c[!grepl("PBS|blank|Blank",l3c$ECMp)]

#Make the FBS in each plate unique
l3c$Ligand[grepl("FBS",l3c$Ligand)] <- paste0("FBS",gsub("LI8XXX00|LI8X00|reDAPI","",l3c$Barcode[grepl("FBS",l3c$Ligand)]))
l3c$MEP<- paste(l3c$ECMp,l3c$Ligand,sep="_")

#RUV3 Normalize each signal
metadataNames <- grep("_CP_|_PA_",colnames(dt), value=TRUE, invert=TRUE)
#Save the metadata to merge in later
mdDT <- l3c[,metadataNames, with = FALSE]
#Identify parameters to be normalized
signalsWithMetadata <- grep("^Barcode$|^ECMp$|^Ligand$|^Well$|^Spot$|^ArrayRow$|^ArrayColumn$|_CP_|_PA_",colnames(l3c),value=TRUE)
l3s <- l3c[,signalsWithMetadata, with=FALSE]
#Normalize each feature, pass with location and content metadata
if(verbose) {
  cat("Normalizing\n")
  #save(slDT, file="slDT.RData")
}

 calcResidual <- function (x) 
{
    mel <- as.numeric(median(x, na.rm = TRUE))
    return(x - mel)
}
 
#'Apply RUV3 and Loess Normalization to the common signals in a dataset
#' @export
normRUV3LoessResidualsCS <- function(dt, k){
  setkey(dt,Barcode,Well,Ligand,ECMp)
  signalNames <- grep("_CP_|_PA_",colnames(dt), value=TRUE)

  #Add residuals from subtracting the biological medians from each value
  residuals <- dt[,lapply(.SD,calcResidual), by="Barcode,Well,Ligand,ECMp", .SDcols=signalNames]
  #Add within array location metadata
  residuals$Spot <- as.integer(dt$Spot)
  residuals$ArrayRow <- dt$ArrayRow
  residuals$ArrayColumn <- dt$ArrayColumn
  #Create a signal type
  dt$SignalType <- "Signal"
  residuals$SignalType <- "Residual"
  srDT <- rbind(dt,residuals)
  
  #Add to carry metadata into matrices
  srDT$BWL <- paste(srDT$Barcode, srDT$Well, srDT$Ligand, sep="_") 
  srDT$SERC <- paste(srDT$Spot,srDT$ECMp, srDT$ArrayRow, srDT$ArrayColumn, sep="_")
  
  #Set up the M Matrix to denote replicates
  nrControlWells <- sum(grepl("FBS",unique(srDT$BWL[srDT$SignalType=="Signal"])))
  nrLigandWells <- length(unique(srDT$BWL[srDT$SignalType=="Signal"]))-nrControlWells
  M <-matrix(0, nrow = length(unique(srDT$BWL[srDT$SignalType=="Signal"])), ncol = nrLigandWells+1)
  rownames(M) <- unique(srDT$BWL[srDT$SignalType=="Signal"])
  #Indicate the control wells in the last column
  Mc <- M[grepl("FBS",rownames(M)),]
  Mc[,ncol(Mc)] <-1L
  #Subset to the ligand wells and mark as non-replicate
  Ml <- M[!grepl("FBS",rownames(M)),]
  for(i in 1:nrLigandWells) {
    Ml[i,i] <- 1
  }
  #Add the replicate wells and restore the row order
  M <- rbind(Mc,Ml)
  M <- M[order(rownames(M)),]
  #TODO verify M matrix and work within MEMA package
  srmList <- lapply(signalNames, function(signalName, dt){
    srm <- MEMA:::signalResidualMatrix(dt[,.SD, .SDcols=c("BWL", "SERC", "SignalType", signalName)])
    return(srm)
  },dt=srDT)
  
  
  names(srmList) <- signalNames
  
  srmRUV3List <- lapply(names(srmList), function(srmName, srmList, M, k){
    Y <- srmList[[srmName]]
    #Hardcode in identification of residuals as the controls
    resStart <- ncol(Y)/2+1
    cIdx=resStart:ncol(Y)
    nY <- RUVIIIArrayWithResiduals(k, Y, M, cIdx, srmName) #Normalize the spot level data
    nY$k <- k
    nY$SignalName <- paste0(srmName,"RUV3")
    setnames(nY,srmName,paste0(srmName,"RUV3"))
    return(nY)
  }, srmList=srmList, M=M, k=k)
  
  #Add Loess normalized values for each signal
  RUV3LoessList <- lapply(srmRUV3List, function(dt){
    dtRUV3Loess <- loessNormArray(dt)
  })
  
  #Combine the normalized signal into one data.table
  #with one set of metadata
  signalDT <- do.call(cbind,lapply(RUV3LoessList, function(dt){
    sdt <- dt[,grep("_CP_|_PA_",colnames(dt)), with=FALSE]
  }))
  
  signalMetadataDT <- cbind(RUV3LoessList[[1]][,grep("_CP_|_PA_",colnames(RUV3LoessList[[1]]), invert=TRUE), with=FALSE], signalDT)
  signalMetadataDT <- signalMetadataDT[,SignalName := NULL]
  signalMetadataDT <- signalMetadataDT[,mel := NULL]
  signalMetadataDT <- signalMetadataDT[,Residual := NULL]
  return(signalMetadataDT)
}

nDT <- normRUV3LoessResiduals(slDT[,signalsWithMetadata, with = FALSE], k)
nDT$NormMethod <- "RUV3LoessResiduals"


l4 <- createl4KeepRaw(l3)

# l4 <- fread(paste0("./",cellLine,"/",ss,"/AnnotatedData/",cellLine, "_",ss,"_",rawDataVersion,"_",analysisVersion,"_Level4.txt"), showProgress = FALSE)
# l4 <- l4[,grep("AnnotID",colnames(l4),invert=TRUE, value=TRUE), with=FALSE]
# l4$Ligand[grepl("FBS",l4$Ligand)] <- paste("FBS",sub("LI8XXX00","",l4$Barcode[grepl("FBS",l4$Ligand)]))
# l4$MEP<- paste(l4$ECMp,l4$Ligand,sep="_")

barcodes <- sort(unique(l4$Barcode))

#Set a threshold for filtering wells on their QA score
wellQAThresh <- 0.8

#TODO: Read this from Level 3 data
lthresh <- 0.6

#Number of PCS components to use
nrPCs <- 9

#Z score threshold for extreme spot cell count
SCCZscoreThresh <- 3

#Spot cell count threshold for HF dataset
HFSCCThresh <- 20

#Replicate count threshold for HF Dataset
HFRepThresh <- 3

# https://meplincs.ohsu.edu/webclient/

if(!analysisVersion=="v1"){
  l3$OmeroDetailURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/img_detail/',l3$ImageID,'/"',' target="_blank">Omero</a>')
  l3$OmeroThumbnailURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/render_thumbnail/',l3$ImageID,'/"',' target="_blank">Omero</a>')
  l3$OmeroImageURL <- paste0('<a href="https://meplincs.ohsu.edu/webclient/render_image/',l3$ImageID,'/"',' target="_blank">Omero</a>')
}

```


#MEP-LINCS `r cellLine` `r ss` Phase 1 PCA Normalization Evaluation
####date: `r Sys.Date()`

##Summary
The MEP-LINCS `r cellLine` `r ss` datasets include four levels of high content imaging data from on Microenvironment Microarrays (MEMAs). After QA filtering, there are `r nrow(l4[!grepl("PBS|Fiducial",l4$ECMp),][!grepl("FBS",l4$Ligand)])` Microenvironment Perturbations (MEPs) that are pairwise combinations of `r length(unique(l4$ECMp[!grepl("PBS|Fiducial",l4$ECMp)]))` printed ECM proteins and `r length(unique(l4$Ligand[!grepl("FBS",l4$Ligand)]))` ligands or growth factors.  


```{r PCARawData, eval=TRUE}


###PCA Unbiased Analysis  
# The unbiased analysis is extended by using Principal Component Analysis (PCA) to reduce the dimensions of the feature vector.
# 
# The unbiased PCA analysis method is:
# Use PCA to transform the entire raw feature set to a much smaller number of principal components (PCFV).  
# Perform unsupervised hierarchical clustering of the first `r nrPCs` PCFVs.  
# 


#Get a PCA model from the raw data
rawFVNames <- grep("ECMp|Ligand|MEP|Barcode|Well|Loess|RUV3",colnames(l4),invert = TRUE, value = TRUE)
rawPCAModel <- createPCAModel(dt=l4, fvNames = rawFVNames)

#Get a PCA model from the RUV3 data
RUV3Names <- grep("RUV3$",colnames(l4), value=TRUE)
RUV3PCAModel <- createPCAModel(dt=l4, fvNames = RUV3Names)

#Get a PCA model from the RUV3Loess data
RUV3LoessNames <- grep("RUV3Loess$",colnames(l4), value=TRUE)
RUV3LoessPCAModel <- createPCAModel(dt=l4, fvNames = RUV3LoessNames)

```

```{r PCAHeatmap, fig.height=8, fig.width=7, eval=FALSE}
# #Extract the first PCs of each MEP into a matrix
# l4RawpcvDT <- data.table(l4RawPCAModel$x[,1:nrPCs],Barcode =l4WithRaw$Barcode, MEP = l4WithRaw$MEP)
# 
# #Convert to dataframe for use in D3heatmap
# l4RawpcvDF <- data.frame(l4RawpcvDT)
# rownames(l4RawpcvDF) <- l4RawpcvDT$MEP
# l4RawpcvDF <- l4RawpcvDF[,!(names(l4RawpcvDF) %in% c("MEP", "Barcode"))]

#Plot the heat map of the entire dataset
d3heatmap(l4WithRawpcvDF, scale="column", colors=hmcols, xaxis_font_size="6pt", yaxis_font_size="4pt", show_grid = FALSE)

```

```{r plotRawPCA, fig.height=3, fig.width=4}
plotScree(m = rawPCAModel, main=list("PCA Scree Plot of Raw Data",cex = .9))

plotPCs(m = rawPCAModel,PCs = c("PC1","PC2","PC3"),colour = "l4$Barcode", title = "PCA of Raw Data", legendTitle = "Barcode")

#plotPCs(m = rawPCAModel,PCs = c("PC1","PC2","PC3"),colour = "l4$Well", title = "PCA of Raw Data", legendTitle = "Well")
```

```{r plotRUV3PCA, fig.height=3, fig.width=4}
plotScree(m = RUV3PCAModel, main=list("PCA Scree Plot of RUV3 Normalized Data",cex = .9))

plotPCs(m = RUV3PCAModel,PCs = c("PC1","PC2","PC3"),colour = "l4$Barcode", title = "PCA of RUV3 Normalized Data", legendTitle = "Barcode")

#plotPCs(m = RUV3PCAModel,PCs = c("PC1","PC2","PC3"),colour = "l4$Well", title = "PCA of RUV3 Normalized Data", legendTitle = "Well")

```

```{r plotRUV3LoessPCA, fig.height=3, fig.width=4}
plotScree(m = RUV3LoessPCAModel, main=list("PCA Scree Plot of RUV3Loess Normalized Data",cex = .9))

plotPCs(m = RUV3LoessPCAModel,PCs = c("PC1","PC2","PC3"),colour = "l4$Barcode", title = "PCA of RUV3Loess Normalized Data", legendTitle = "Barcode")

#plotPCs(m = RUV3LoessPCAModel,PCs = c("PC1","PC2","PC3"),colour = "l4$Well", title = "PCA of RUV3Loess Normalized Data", legendTitle = "Well")

```

```{r SCC}

dt <- l4[,list(Barcode,Ligand,Spot_PA_SpotCellCountLog2, Spot_PA_SpotCellCountLog2RUV3, Spot_PA_SpotCellCountLog2RUV3Loess )]
dt <- melt(dt,id.vars=c("Barcode","Ligand"),measure.vars=c("Spot_PA_SpotCellCountLog2","Spot_PA_SpotCellCountLog2RUV3","Spot_PA_SpotCellCountLog2RUV3Loess"), variable.name = "Processed",value.name = "SpotCellCount", variable.factor = FALSE)
dt$Processed[!grepl("RUV3",dt$Processed)] <- "RawLog2"
dt$Processed[grepl("RUV3$",dt$Processed)] <- "RUV3"
dt$Processed[grepl("RUV3Loess",dt$Processed)] <- "RUV3Loess"

p <- ggplot(dt, aes(x = reorder(Barcode, SpotCellCount, FUN=median), y = SpotCellCount, colour = Ligand))+geom_boxplot()+
  ggtitle(paste("MEP Normalized Spot Cell Count by Barcode (full dataset)"))+
  xlab("")+ylab("")+
  facet_wrap(~Processed, ncol=1)+
  guides(colour=guide_legend(ncol=3))+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
#p <- p+geom_hline(yintercept = median(dt$SpotCellCount), colour="blue", alpha=.5)
suppressWarnings(print(p))

p <- ggplot(dt, aes(x = factor(Ligand), y = SpotCellCount, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("MEP Normalized Spot Cell Count by Ligand (full dataset)"))+
  xlab("")+ylab("")+
  facet_wrap(~Processed, ncol=1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
#p <- p+geom_hline(yintercept = median(dt$SpotCellCount), colour="blue", alpha=.5)
suppressWarnings(print(p))

dt <- l4[,list(Barcode,ECMp,Spot_PA_SpotCellCountLog2, Spot_PA_SpotCellCountLog2RUV3, Spot_PA_SpotCellCountLog2RUV3Loess )]
dt <- melt(dt,id.vars=c("Barcode","ECMp"),measure.vars=c("Spot_PA_SpotCellCountLog2","Spot_PA_SpotCellCountLog2RUV3","Spot_PA_SpotCellCountLog2RUV3Loess"), variable.name = "Processed",value.name = "SpotCellCount", variable.factor = FALSE)
dt$Processed[!grepl("RUV3",dt$Processed)] <- "RawLog2"
dt$Processed[grepl("RUV3$",dt$Processed)] <- "RUV3"
dt$Processed[grepl("RUV3Loess",dt$Processed)] <- "RUV3Loess"

p <- ggplot(dt, aes(x = factor(ECMp), y = SpotCellCount))+geom_boxplot()+
  ggtitle(paste("MEP Normalized Spot Cell Count by ECM Protein (full dataset)"))+
  xlab("")+ylab("")+
  facet_wrap(~Processed, ncol=1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
#p <- p+geom_hline(yintercept = median(dt$SpotCellCount), colour="blue", alpha=.5)
suppressWarnings(print(p))

p <- ggplot(dt, aes(x = factor(ECMp), y = SpotCellCount, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("MEP Normalized Spot Cell Count by ECM Protein and Barcode (full dataset)"))+
  xlab("")+ylab("")+
  facet_wrap(~Processed, ncol=1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
#p <- p+geom_hline(yintercept = median(dt$SpotCellCount), colour="blue", alpha=.5)
suppressWarnings(print(p))

```


```{r EdU}

dt <- l4[,list(Barcode,Ligand,Nuclei_PA_Gated_EduPositiveLogit, Nuclei_PA_Gated_EduPositiveLogitRUV3, Nuclei_PA_Gated_EduPositiveLogitRUV3Loess )]
dt <- melt(dt,id.vars=c("Barcode","Ligand"),measure.vars=c("Nuclei_PA_Gated_EduPositiveLogit","Nuclei_PA_Gated_EduPositiveLogitRUV3","Nuclei_PA_Gated_EduPositiveLogitRUV3Loess"), variable.name = "Processed",value.name = "EdU", variable.factor = FALSE)
dt$Processed[!grepl("RUV3",dt$Processed)] <- "RawLogit"
dt$Processed[grepl("RUV3$",dt$Processed)] <- "RUV3"
dt$Processed[grepl("RUV3Loess",dt$Processed)] <- "RUV3Loess"

p <- ggplot(dt, aes(x = factor(Barcode), y = EdU, colour = Ligand))+geom_boxplot()+
  ggtitle(paste("MEP Normalized EdU Positive Proportion by Barcode (full dataset)"))+
  xlab("")+ylab("")+
  facet_wrap(~Processed, ncol=1)+
  guides(colour=guide_legend(ncol=3))+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
#p <- p+geom_hline(yintercept = median(dt$EdU), colour="blue", alpha=.5)
suppressWarnings(print(p))

p <- ggplot(dt, aes(x = factor(Ligand), y = EdU, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("MEP Normalized EdU Positive Proportion by Ligand (full dataset)"))+
  xlab("")+ylab("")+
  facet_wrap(~Processed, ncol=1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
#p <- p+geom_hline(yintercept = median(dt$EdU), colour="blue", alpha=.5)
suppressWarnings(print(p))

dt <- l4[,list(Barcode,ECMp,Nuclei_PA_Gated_EduPositiveLogit, Nuclei_PA_Gated_EduPositiveLogitRUV3, Nuclei_PA_Gated_EduPositiveLogitRUV3Loess )]

dt <- melt(dt,id.vars=c("Barcode","ECMp"),measure.vars=c("Nuclei_PA_Gated_EduPositiveLogit","Nuclei_PA_Gated_EduPositiveLogitRUV3","Nuclei_PA_Gated_EduPositiveLogitRUV3Loess"), variable.name = "Processed",value.name = "EdU", variable.factor = FALSE)
dt$Processed[!grepl("RUV3",dt$Processed)] <- "RawLogit"
dt$Processed[grepl("RUV3$",dt$Processed)] <- "RUV3"
dt$Processed[grepl("RUV3Loess",dt$Processed)] <- "RUV3Loess"

p <- ggplot(dt, aes(x = factor(ECMp), y = EdU))+geom_boxplot()+
  ggtitle(paste("MEP Normalized EdU Positive Proportion by ECM Protein (full dataset)"))+
  xlab("")+ylab("")+
  facet_wrap(~Processed, ncol=1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
#p <- p+geom_hline(yintercept = median(dt$EdU), colour="blue", alpha=.5)
suppressWarnings(print(p))

p <- ggplot(dt, aes(x = factor(ECMp), y = EdU, colour = Barcode))+geom_boxplot()+
  ggtitle(paste("MEP Normalized EdU Positive Proportion by ECM Protein and Barcode (full dataset)"))+
  xlab("")+ylab("")+
  facet_wrap(~Processed, ncol=1)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
#p <- p+geom_hline(yintercept = median(dt$EdU), colour="blue", alpha=.5)
suppressWarnings(print(p))

```